{"version":3,"sources":["webpack:///./node_modules/superstruct/lib/index.es.js"],"names":["StructError","attrs","_this","_classCallCheck","this","message","format","_getPrototypeOf","call","data","path","value","reason","type","_attrs$errors","errors","length","push","_assertThisInitialized","Error","captureStackTrace","constructor","stack","TypeError","concat","join","JSON","stringify","toString","Object","prototype","kindOf","val","_typeof","ctorName","Array","isArray","isBuffer","callee","err","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","next","isGeneratorObj","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","_extends","assign","target","i","arguments","source","key","hasOwnProperty","Kind","validate","any","schema","defaults$$1","options","tuple","list","func","object","required","endsWith","includes","union","split","intersection","scalar","optional","undefined","en","map","s","e","String","isValid","result","failure","array","element","_array$validate2","_slicedToArray","error","ret","_loop3","v","_element$validate2","r","forEach","singleE","first","obj","ks","properties","kind","valueKeys","keys","propertiesKeys","Set","_kind$validate4","fn","types","_kind$validate8","kinds","k","Math","max","_loop5","_kind$validate10","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","_k2$validate2","t","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_t$validate2","Kinds","dict","values","resolved","_loop","_k","_keys$validate2","_values$validate2","e2","r2","enum","enums","function","instance","interface","_loop2","_kind$validate2","lazy","struct","literal","partial","_loop4","_kind$validate6","dynamic","createSchema","_schema$validate2","Types","superstruct","config","Struct","assert","defineProperty","_kind$validate12","test","_kind$validate16","date","isNaN"],"mappings":"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","file":"chunk.eeebdfdc739e541fdd6c.js","sourcesContent":["/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs;\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${JSON.stringify(value)}\\`.`;\n    return message;\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs);\n    super(message);\n\n    const { data, path, value, reason, type, errors = [] } = attrs;\n    this.data = data;\n    this.path = path;\n    this.value = value;\n    this.reason = reason;\n    this.type = type;\n    this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(this);\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error().stack;\n    }\n  }\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@';\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@';\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name;\n    this.type = type;\n    this.validate = validate;\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        let required = true;\n        let type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          const scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          const scalars = schema.split(/\\s*&\\s*/g);\n          type = intersection(scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);\n  } else {\n    throw new Error(`Invalid schema: ${schema}`);\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const keys = any(schema[0], undefined, options);\n  const values = any(schema[1], undefined, options);\n  const name = 'dict';\n  const type = `dict<${keys.type},${values.type}>`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = {};\n    const errors = [];\n\n    for (let k in value) {\n      const v = value[k];\n      const [e, r] = keys.validate(k);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      k = r;\n      const [e2, r2] = values.validate(v);\n\n      if (e2) {\n        const allE2 = e2.errors || [e2];\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[k] = r2;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'enum';\n  const type = schema.map(s => {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults$$1, options) {\n  const e = en(schema, undefined, options);\n  const l = list([e], defaults$$1, options);\n  return l;\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'function';\n  const type = '<function>';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const result = schema(value, data);\n    let failure = { path: [], reason: null };\n    let isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n      default:\n        {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`);\n          } else {\n            throw new Error(`Invalid result: ${result}`);\n          }\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({ type, value, data: value }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults$$1, options) {\n  const name = 'instance';\n  const type = `instance<${schema.name}>`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'interface';\n  const type = `{${ks.join()}}`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const errors = [];\n    const ret = value;\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  let kind;\n  let struct;\n  const name = 'lazy';\n  const type = `lazy...`;\n  const compile = value => {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dynamic structs must be defined as a function, but you passed: ${createSchema}`);\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`);\n    }\n  }\n\n  const name = 'dynamic';\n  const type = 'dynamic...';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Dynamic structs must return a schema, but you passed: ${schema}`);\n      } else {\n        throw new Error(`Invalid schema: ${schema}`);\n      }\n    }\n\n    const [error, result] = schema.validate(value);\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const array = scalar('array', undefined, options);\n  const element = any(schema[0], undefined, options);\n  const name = 'list';\n  const type = `[${element.type}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error, result] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    const errors = [];\n    const ret = [];\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      const [e, r] = element.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults$$1, options) {\n  const name = 'literal';\n  const type = `literal: ${JSON.stringify(schema)}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'object';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n    const valueKeys = Object.keys(value);\n    const propertiesKeys = Object.keys(properties);\n    const keys = new Set(valueKeys.concat(propertiesKeys));\n\n    keys.forEach(key => {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v };\n        errors.push(e);\n        return;\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'partial';\n  const type = `{${ks.join()},...}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const { types } = options;\n  const fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`No struct validator function found for type \"${schema}\".`);\n    } else {\n      throw new Error(`Invalid type: ${schema}`);\n    }\n  }\n\n  const kind = func(fn, defaults$$1, options);\n  const name = 'scalar';\n  const type = schema;\n  const validate = value => {\n    const [error, result] = kind.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const array = scalar('array', undefined, options);\n  const name = 'tuple';\n  const type = `[${kinds.map(k => k.type).join()}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = [];\n    const errors = [];\n    const length = Math.max(value.length, kinds.length);\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i];\n      const v = value[i];\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v };\n        errors.push(e);\n        continue;\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const name = 'union';\n  const type = kinds.map(k => k.type).join(' | ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const errors = [];\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value);\n\n      if (!e) {\n        return [undefined, r];\n      }\n\n      errors.push(e);\n    }\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options));\n  const name = 'intersection';\n  const type = types.map(t => t.type).join(' & ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    let v = value;\n\n    for (const t of types) {\n      const [e, r] = t.validate(v);\n\n      if (e) {\n        e.type = type;\n        return [e];\n      }\n\n      v = r;\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic\n\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined\n};\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type;\n});\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value);\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = _extends({}, Types, config.types || {});\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults$$1, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true });\n    Object.defineProperty(Struct, KIND, { value: kind });\n\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = value => {\n      const [error] = kind.validate(value);\n      return !error;\n    };\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name];\n\n    struct[name] = (schema, defaults$$1, options) => {\n      const type = kind(schema, defaults$$1, _extends({}, options, { types }));\n      const s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct();\n\nexport { struct, superstruct, isStruct, StructError };\n//# sourceMappingURL=index.es.js.map\n"],"sourceRoot":""}