# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _eva
else:
    import _eva

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _eva.SWIG_PyInstanceMethod_New
_swig_new_static_method = _eva.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _eva.delete_SwigPyIterator
    value = _swig_new_instance_method(_eva.SwigPyIterator_value)
    incr = _swig_new_instance_method(_eva.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_eva.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_eva.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_eva.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_eva.SwigPyIterator_copy)
    next = _swig_new_instance_method(_eva.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_eva.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_eva.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_eva.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_eva.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_eva.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_eva.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_eva.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_eva.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_eva.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _eva:
_eva.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _eva.SHARED_PTR_DISOWN
BOOST_LOG_DYN_LINK = _eva.BOOST_LOG_DYN_LINK
class Communication(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get = _swig_new_static_method(_eva.Communication_get)
    __swig_destroy__ = _eva.delete_Communication
    get_p2p_channel = _swig_new_instance_method(_eva.Communication_get_p2p_channel)
    register_p2p_communication = _swig_new_instance_method(_eva.Communication_register_p2p_communication)
    safe_barrier = _swig_new_instance_method(_eva.Communication_safe_barrier)
    update_communicators = _swig_new_instance_method(_eva.Communication_update_communicators)
    mpiSupport = property(_eva.Communication_mpiSupport_get, _eva.Communication_mpiSupport_set)
    rank = property(_eva.Communication_rank_get, _eva.Communication_rank_set)
    ranksCount = property(_eva.Communication_ranksCount_get, _eva.Communication_ranksCount_set)
    hosts = property(_eva.Communication_hosts_get, _eva.Communication_hosts_set)

# Register Communication in _eva:
_eva.Communication_swigregister(Communication)
Communication_get = _eva.Communication_get

LOG_OUTPUT_FILE = _eva.LOG_OUTPUT_FILE
LOG_DEBUG_FILE = _eva.LOG_DEBUG_FILE
DEFAULT_DEBUG_ENABLED = _eva.DEFAULT_DEBUG_ENABLED
LogSeverity_DEBUG = _eva.LogSeverity_DEBUG
LogSeverity_MESSAGE = _eva.LogSeverity_MESSAGE
LogSeverity_WARNING = _eva.LogSeverity_WARNING
LogSeverity_ERROR = _eva.LogSeverity_ERROR
LogSeverity_FATAL = _eva.LogSeverity_FATAL
LogSeverity_EXTERNAL = _eva.LogSeverity_EXTERNAL
LogPriority_LOW = _eva.LogPriority_LOW
LogPriority_MEDIUM = _eva.LogPriority_MEDIUM
LogPriority_HIGH = _eva.LogPriority_HIGH
class Log(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    priority0_lg = property(_eva.Log_priority0_lg_get, _eva.Log_priority0_lg_set)
    priority1_lg = property(_eva.Log_priority1_lg_get, _eva.Log_priority1_lg_set)
    priority2_lg = property(_eva.Log_priority2_lg_get, _eva.Log_priority2_lg_set)
    error_lg = property(_eva.Log_error_lg_get, _eva.Log_error_lg_set)
    fatal_lg = property(_eva.Log_fatal_lg_get, _eva.Log_fatal_lg_set)
    output_min_severity = property(_eva.Log_output_min_severity_get, _eva.Log_output_min_severity_set)
    output_min_priority = property(_eva.Log_output_min_priority_get, _eva.Log_output_min_priority_set)
    debug_min_severity = property(_eva.Log_debug_min_severity_get, _eva.Log_debug_min_severity_set)
    debug_min_priority = property(_eva.Log_debug_min_priority_get, _eva.Log_debug_min_priority_set)
    debug_enabled = property(_eva.Log_debug_enabled_get, _eva.Log_debug_enabled_set)
    get = _swig_new_static_method(_eva.Log_get)
    flush = _swig_new_instance_method(_eva.Log_flush)
    __swig_destroy__ = _eva.delete_Log

# Register Log in _eva:
_eva.Log_swigregister(Log)
cvar = _eva.cvar
Log_get = _eva.Log_get

class Parameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == Parameters:
            _self = None
        else:
            _self = self
        _eva.Parameters_swiginit(self, _eva.new_Parameters(_self, ))
    __swig_destroy__ = _eva.delete_Parameters
    dereference = _swig_new_static_method(_eva.Parameters_dereference)
    get_shared = _swig_new_static_method(_eva.Parameters_get_shared)
    load = _swig_new_instance_method(_eva.Parameters_load)
    get_values = _swig_new_instance_method(_eva.Parameters_get_values)
    tree = property(_eva.Parameters_tree_get, _eva.Parameters_tree_set)
    map = property(_eva.Parameters_map_get, _eva.Parameters_map_set)
    def __disown__(self):
        self.this.disown()
        _eva.disown_Parameters(self)
        return weakref.proxy(self)

# Register Parameters in _eva:
_eva.Parameters_swigregister(Parameters)
Parameters_dereference = _eva.Parameters_dereference
Parameters_get_shared = _eva.Parameters_get_shared

class Scheme(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _eva.Scheme_swiginit(self, _eva.new_Scheme())
    __swig_destroy__ = _eva.delete_Scheme
    validate = _swig_new_instance_method(_eva.Scheme_validate)
    load = _swig_new_instance_method(_eva.Scheme_load)
    filter = _swig_new_instance_method(_eva.Scheme_filter)
    include = _swig_new_instance_method(_eva.Scheme_include)
    name = property(_eva.Scheme_name_get, _eva.Scheme_name_set)
    get_rules = _swig_new_instance_method(_eva.Scheme_get_rules)

# Register Scheme in _eva:
_eva.Scheme_swigregister(Scheme)
SCHEMES_GROUP = cvar.SCHEMES_GROUP
SCHEMES_BASE = cvar.SCHEMES_BASE
SCHEMES_PARAM = cvar.SCHEMES_PARAM
SCHEMES_CLASS = cvar.SCHEMES_CLASS
SCHEMES_ROOT = cvar.SCHEMES_ROOT
SCHEMES_CAPTION = cvar.SCHEMES_CAPTION
SCHEMES_TYPE = cvar.SCHEMES_TYPE
SCHEMES_DEFAULT = cvar.SCHEMES_DEFAULT
SCHEMES_DESCRIPION = cvar.SCHEMES_DESCRIPION
SCHEMES_TYPE_FILE = cvar.SCHEMES_TYPE_FILE
SCHEMES_TYPE_INT = cvar.SCHEMES_TYPE_INT
SCHEMES_TYPE_FLOAT = cvar.SCHEMES_TYPE_FLOAT
SCHEMES_TYPE_ARRAY = cvar.SCHEMES_TYPE_ARRAY

METADATA_VAR = _eva.METADATA_VAR
GENESIS_LOCATION = _eva.GENESIS_LOCATION
class BaseClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _eva.delete_BaseClass
    gen_scheme = _swig_new_static_method(_eva.BaseClass_gen_scheme)

    def __init__(self):
        if self.__class__ == BaseClass:
            _self = None
        else:
            _self = self
        _eva.BaseClass_swiginit(self, _eva.new_BaseClass(_self, ))
    def __disown__(self):
        self.this.disown()
        _eva.disown_BaseClass(self)
        return weakref.proxy(self)

# Register BaseClass in _eva:
_eva.BaseClass_swigregister(BaseClass)
BaseClass_gen_scheme = _eva.BaseClass_gen_scheme

class exception_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.exception_base_what)

    def __init__(self):
        _eva.exception_base_swiginit(self, _eva.new_exception_base())
    __swig_destroy__ = _eva.delete_exception_base

# Register exception_base in _eva:
_eva.exception_base_swigregister(exception_base)

class outofdomain_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.outofdomain_error_what)

    def __init__(self):
        _eva.outofdomain_error_swiginit(self, _eva.new_outofdomain_error())
    __swig_destroy__ = _eva.delete_outofdomain_error

# Register outofdomain_error in _eva:
_eva.outofdomain_error_swigregister(outofdomain_error)

class inconsistency_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.inconsistency_error_what)

    def __init__(self):
        _eva.inconsistency_error_swiginit(self, _eva.new_inconsistency_error())
    __swig_destroy__ = _eva.delete_inconsistency_error

# Register inconsistency_error in _eva:
_eva.inconsistency_error_swigregister(inconsistency_error)

class param_value_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.param_value_error_what)

    def __init__(self):
        _eva.param_value_error_swiginit(self, _eva.new_param_value_error())
    __swig_destroy__ = _eva.delete_param_value_error

# Register param_value_error in _eva:
_eva.param_value_error_swigregister(param_value_error)

class status_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.status_error_what)

    def __init__(self):
        _eva.status_error_swiginit(self, _eva.new_status_error())
    __swig_destroy__ = _eva.delete_status_error

# Register status_error in _eva:
_eva.status_error_swigregister(status_error)

class flow_control_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.flow_control_error_what)

    def __init__(self):
        _eva.flow_control_error_swiginit(self, _eva.new_flow_control_error())
    __swig_destroy__ = _eva.delete_flow_control_error

# Register flow_control_error in _eva:
_eva.flow_control_error_swigregister(flow_control_error)

class malformed_record(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.malformed_record_what)

    def __init__(self):
        _eva.malformed_record_swiginit(self, _eva.new_malformed_record())
    __swig_destroy__ = _eva.delete_malformed_record

# Register malformed_record in _eva:
_eva.malformed_record_swigregister(malformed_record)

class unsupported_feature(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.unsupported_feature_what)

    def __init__(self):
        _eva.unsupported_feature_swiginit(self, _eva.new_unsupported_feature())
    __swig_destroy__ = _eva.delete_unsupported_feature

# Register unsupported_feature in _eva:
_eva.unsupported_feature_swigregister(unsupported_feature)

class factory_unknown_type(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.factory_unknown_type_what)

    def __init__(self):
        _eva.factory_unknown_type_swiginit(self, _eva.new_factory_unknown_type())
    __swig_destroy__ = _eva.delete_factory_unknown_type

# Register factory_unknown_type in _eva:
_eva.factory_unknown_type_swigregister(factory_unknown_type)

class wrong_behaviour(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.wrong_behaviour_what)

    def __init__(self):
        _eva.wrong_behaviour_swiginit(self, _eva.new_wrong_behaviour())
    __swig_destroy__ = _eva.delete_wrong_behaviour

# Register wrong_behaviour in _eva:
_eva.wrong_behaviour_swigregister(wrong_behaviour)

class unexpected_instance_type(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.unexpected_instance_type_what)

    def __init__(self):
        _eva.unexpected_instance_type_swiginit(self, _eva.new_unexpected_instance_type())
    __swig_destroy__ = _eva.delete_unexpected_instance_type

# Register unexpected_instance_type in _eva:
_eva.unexpected_instance_type_swigregister(unexpected_instance_type)

class unprovided_artifact(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.unprovided_artifact_what)

    def __init__(self):
        _eva.unprovided_artifact_swiginit(self, _eva.new_unprovided_artifact())
    __swig_destroy__ = _eva.delete_unprovided_artifact

# Register unprovided_artifact in _eva:
_eva.unprovided_artifact_swigregister(unprovided_artifact)

class incomplete_metadata(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.incomplete_metadata_what)

    def __init__(self):
        _eva.incomplete_metadata_swiginit(self, _eva.new_incomplete_metadata())
    __swig_destroy__ = _eva.delete_incomplete_metadata

# Register incomplete_metadata in _eva:
_eva.incomplete_metadata_swigregister(incomplete_metadata)

class internal_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.internal_error_what)

    def __init__(self):
        _eva.internal_error_swiginit(self, _eva.new_internal_error())
    __swig_destroy__ = _eva.delete_internal_error

# Register internal_error in _eva:
_eva.internal_error_swigregister(internal_error)

class incompatible_solver(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.incompatible_solver_what)

    def __init__(self):
        _eva.incompatible_solver_swiginit(self, _eva.new_incompatible_solver())
    __swig_destroy__ = _eva.delete_incompatible_solver

# Register incompatible_solver in _eva:
_eva.incompatible_solver_swigregister(incompatible_solver)

class invalid_mpi_thread_support(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.invalid_mpi_thread_support_what)

    def __init__(self):
        _eva.invalid_mpi_thread_support_swiginit(self, _eva.new_invalid_mpi_thread_support())
    __swig_destroy__ = _eva.delete_invalid_mpi_thread_support

# Register invalid_mpi_thread_support in _eva:
_eva.invalid_mpi_thread_support_swigregister(invalid_mpi_thread_support)

class unsupported_multi_threading(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.unsupported_multi_threading_what)

    def __init__(self):
        _eva.unsupported_multi_threading_swiginit(self, _eva.new_unsupported_multi_threading())
    __swig_destroy__ = _eva.delete_unsupported_multi_threading

# Register unsupported_multi_threading in _eva:
_eva.unsupported_multi_threading_swigregister(unsupported_multi_threading)

class parameters_validation_failed(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.parameters_validation_failed_what)

    def __init__(self):
        _eva.parameters_validation_failed_swiginit(self, _eva.new_parameters_validation_failed())
    __swig_destroy__ = _eva.delete_parameters_validation_failed

# Register parameters_validation_failed in _eva:
_eva.parameters_validation_failed_swigregister(parameters_validation_failed)

class communication_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.communication_error_what)

    def __init__(self):
        _eva.communication_error_swiginit(self, _eva.new_communication_error())
    __swig_destroy__ = _eva.delete_communication_error

# Register communication_error in _eva:
_eva.communication_error_swigregister(communication_error)

class io_error(exception_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.io_error_what)

    def __init__(self):
        _eva.io_error_swiginit(self, _eva.new_io_error())
    __swig_destroy__ = _eva.delete_io_error

# Register io_error in _eva:
_eva.io_error_swigregister(io_error)

class channel_open_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.channel_open_error_what)

    def __init__(self):
        _eva.channel_open_error_swiginit(self, _eva.new_channel_open_error())
    __swig_destroy__ = _eva.delete_channel_open_error

# Register channel_open_error in _eva:
_eva.channel_open_error_swigregister(channel_open_error)

class channel_write_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.channel_write_error_what)

    def __init__(self):
        _eva.channel_write_error_swiginit(self, _eva.new_channel_write_error())
    __swig_destroy__ = _eva.delete_channel_write_error

# Register channel_write_error in _eva:
_eva.channel_write_error_swigregister(channel_write_error)

class channel_closed_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.channel_closed_error_what)

    def __init__(self):
        _eva.channel_closed_error_swiginit(self, _eva.new_channel_closed_error())
    __swig_destroy__ = _eva.delete_channel_closed_error

# Register channel_closed_error in _eva:
_eva.channel_closed_error_swigregister(channel_closed_error)

class channel_closing_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.channel_closing_error_what)

    def __init__(self):
        _eva.channel_closing_error_swiginit(self, _eva.new_channel_closing_error())
    __swig_destroy__ = _eva.delete_channel_closing_error

# Register channel_closing_error in _eva:
_eva.channel_closing_error_swigregister(channel_closing_error)

class file_open_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.file_open_error_what)

    def __init__(self):
        _eva.file_open_error_swiginit(self, _eva.new_file_open_error())
    __swig_destroy__ = _eva.delete_file_open_error

# Register file_open_error in _eva:
_eva.file_open_error_swigregister(file_open_error)

class file_format_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.file_format_error_what)

    def __init__(self):
        _eva.file_format_error_swiginit(self, _eva.new_file_format_error())
    __swig_destroy__ = _eva.delete_file_format_error

# Register file_format_error in _eva:
_eva.file_format_error_swigregister(file_format_error)

class file_read_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.file_read_error_what)

    def __init__(self):
        _eva.file_read_error_swiginit(self, _eva.new_file_read_error())
    __swig_destroy__ = _eva.delete_file_read_error

# Register file_read_error in _eva:
_eva.file_read_error_swigregister(file_read_error)

class file_write_error(io_error):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    what = _swig_new_instance_method(_eva.file_write_error_what)

    def __init__(self):
        _eva.file_write_error_swiginit(self, _eva.new_file_write_error())
    __swig_destroy__ = _eva.delete_file_write_error

# Register file_write_error in _eva:
_eva.file_write_error_swigregister(file_write_error)

class CommonTimer(BaseClass):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonTimer:
            _self = None
        else:
            _self = self
        _eva.CommonTimer_swiginit(self, _eva.new_CommonTimer(_self, ))
    __swig_destroy__ = _eva.delete_CommonTimer
    get_classname = _swig_new_instance_method(_eva.CommonTimer_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonTimer_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonTimer_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonTimer_get_shared)
    type = property(_eva.CommonTimer_type_get, _eva.CommonTimer_type_set)
    unwrap = _swig_new_static_method(_eva.CommonTimer_unwrap)
    dereference = _swig_new_static_method(_eva.CommonTimer_dereference)
    get = _swig_new_static_method(_eva.CommonTimer_get)
    get_uuid = _swig_new_instance_method(_eva.CommonTimer_get_uuid)
    name = property(_eva.CommonTimer_name_get, _eva.CommonTimer_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonTimer_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonTimer_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonTimer(self)
        return weakref.proxy(self)

# Register CommonTimer in _eva:
_eva.CommonTimer_swigregister(CommonTimer)
CommonTimer_get_shared = _eva.CommonTimer_get_shared
CommonTimer_unwrap = _eva.CommonTimer_unwrap
CommonTimer_dereference = _eva.CommonTimer_dereference
CommonTimer_get = _eva.CommonTimer_get
CommonTimer_gen_scheme = _eva.CommonTimer_gen_scheme

class Timer(CommonTimer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name, report=True):
        if self.__class__ == Timer:
            _self = None
        else:
            _self = self
        _eva.Timer_swiginit(self, _eva.new_Timer(_self, name, report))
    __swig_destroy__ = _eva.delete_Timer
    elapsed = _swig_new_instance_method(_eva.Timer_elapsed)
    stop = _swig_new_instance_method(_eva.Timer_stop)
    start = _swig_new_instance_method(_eva.Timer_start)
    resume = _swig_new_instance_method(_eva.Timer_resume)
    def __disown__(self):
        self.this.disown()
        _eva.disown_Timer(self)
        return weakref.proxy(self)

# Register Timer in _eva:
_eva.Timer_swigregister(Timer)

class _string_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_eva._string_list_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_eva._string_list___nonzero__)
    __bool__ = _swig_new_instance_method(_eva._string_list___bool__)
    __len__ = _swig_new_instance_method(_eva._string_list___len__)
    __getslice__ = _swig_new_instance_method(_eva._string_list___getslice__)
    __setslice__ = _swig_new_instance_method(_eva._string_list___setslice__)
    __delslice__ = _swig_new_instance_method(_eva._string_list___delslice__)
    __delitem__ = _swig_new_instance_method(_eva._string_list___delitem__)
    __getitem__ = _swig_new_instance_method(_eva._string_list___getitem__)
    __setitem__ = _swig_new_instance_method(_eva._string_list___setitem__)
    pop = _swig_new_instance_method(_eva._string_list_pop)
    append = _swig_new_instance_method(_eva._string_list_append)
    empty = _swig_new_instance_method(_eva._string_list_empty)
    size = _swig_new_instance_method(_eva._string_list_size)
    swap = _swig_new_instance_method(_eva._string_list_swap)
    begin = _swig_new_instance_method(_eva._string_list_begin)
    end = _swig_new_instance_method(_eva._string_list_end)
    rbegin = _swig_new_instance_method(_eva._string_list_rbegin)
    rend = _swig_new_instance_method(_eva._string_list_rend)
    clear = _swig_new_instance_method(_eva._string_list_clear)
    get_allocator = _swig_new_instance_method(_eva._string_list_get_allocator)
    pop_back = _swig_new_instance_method(_eva._string_list_pop_back)
    erase = _swig_new_instance_method(_eva._string_list_erase)

    def __init__(self, *args):
        _eva._string_list_swiginit(self, _eva.new__string_list(*args))
    push_back = _swig_new_instance_method(_eva._string_list_push_back)
    front = _swig_new_instance_method(_eva._string_list_front)
    back = _swig_new_instance_method(_eva._string_list_back)
    assign = _swig_new_instance_method(_eva._string_list_assign)
    resize = _swig_new_instance_method(_eva._string_list_resize)
    insert = _swig_new_instance_method(_eva._string_list_insert)
    reserve = _swig_new_instance_method(_eva._string_list_reserve)
    capacity = _swig_new_instance_method(_eva._string_list_capacity)
    __swig_destroy__ = _eva.delete__string_list

# Register _string_list in _eva:
_eva._string_list_swigregister(_string_list)

import genesis.cain
class CommonSolver(BaseClass):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonSolver:
            _self = None
        else:
            _self = self
        _eva.CommonSolver_swiginit(self, _eva.new_CommonSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonSolver
    get_classname = _swig_new_instance_method(_eva.CommonSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonSolver_get_shared)
    type = property(_eva.CommonSolver_type_get, _eva.CommonSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonSolver_dereference)
    get = _swig_new_static_method(_eva.CommonSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonSolver_get_uuid)
    name = property(_eva.CommonSolver_name_get, _eva.CommonSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonSolver(self)
        return weakref.proxy(self)

# Register CommonSolver in _eva:
_eva.CommonSolver_swigregister(CommonSolver)
CommonSolver_get_shared = _eva.CommonSolver_get_shared
CommonSolver_unwrap = _eva.CommonSolver_unwrap
CommonSolver_dereference = _eva.CommonSolver_dereference
CommonSolver_get = _eva.CommonSolver_get
CommonSolver_gen_scheme = _eva.CommonSolver_gen_scheme

class Solver(CommonSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == Solver:
            _self = None
        else:
            _self = self
        _eva.Solver_swiginit(self, _eva.new_Solver(_self, *args))
    __swig_destroy__ = _eva.delete_Solver
    throw_workflow_exception = _swig_new_instance_method(_eva.Solver_throw_workflow_exception)
    config_base = _swig_new_instance_method(_eva.Solver_config_base)
    prepare = _swig_new_instance_method(_eva.Solver_prepare)
    config = _swig_new_instance_method(_eva.Solver_config)
    process = _swig_new_instance_method(_eva.Solver_process)
    get_results = _swig_new_instance_method(_eva.Solver_get_results)
    free_results = _swig_new_instance_method(_eva.Solver_free_results)
    clone = _swig_new_instance_method(_eva.Solver_clone)
    add_architecture = _swig_new_instance_method(_eva.Solver_add_architecture)
    mesh = property(_eva.Solver_mesh_get, _eva.Solver_mesh_set)
    archs = property(_eva.Solver_archs_get, _eva.Solver_archs_set)
    domain = property(_eva.Solver_domain_get, _eva.Solver_domain_set)
    device = property(_eva.Solver_device_get, _eva.Solver_device_set)
    neighbors = property(_eva.Solver_neighbors_get, _eva.Solver_neighbors_set)
    timer = property(_eva.Solver_timer_get, _eva.Solver_timer_set)
    build_comms = _swig_new_instance_method(_eva.Solver_build_comms)
    _pack_data = _swig_new_instance_method(_eva.Solver__pack_data)
    _unpack_data = _swig_new_instance_method(_eva.Solver__unpack_data)
    def __disown__(self):
        self.this.disown()
        _eva.disown_Solver(self)
        return weakref.proxy(self)

# Register Solver in _eva:
_eva.Solver_swigregister(Solver)

class CommonEVA(BaseClass):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonEVA:
            _self = None
        else:
            _self = self
        _eva.CommonEVA_swiginit(self, _eva.new_CommonEVA(_self, ))
    __swig_destroy__ = _eva.delete_CommonEVA
    get_classname = _swig_new_instance_method(_eva.CommonEVA_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonEVA_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonEVA_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonEVA_get_shared)
    type = property(_eva.CommonEVA_type_get, _eva.CommonEVA_type_set)
    unwrap = _swig_new_static_method(_eva.CommonEVA_unwrap)
    dereference = _swig_new_static_method(_eva.CommonEVA_dereference)
    get = _swig_new_static_method(_eva.CommonEVA_get)
    get_uuid = _swig_new_instance_method(_eva.CommonEVA_get_uuid)
    name = property(_eva.CommonEVA_name_get, _eva.CommonEVA_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonEVA_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonEVA_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonEVA(self)
        return weakref.proxy(self)

# Register CommonEVA in _eva:
_eva.CommonEVA_swigregister(CommonEVA)
CommonEVA_get_shared = _eva.CommonEVA_get_shared
CommonEVA_unwrap = _eva.CommonEVA_unwrap
CommonEVA_dereference = _eva.CommonEVA_dereference
CommonEVA_get = _eva.CommonEVA_get
CommonEVA_gen_scheme = _eva.CommonEVA_gen_scheme


   # Import the common module
from genesis import eva
import builtins
import json

builtins.orig_print = builtins.print

# Custom print to decorate the user message
def custom_print(*args, **kwargs):

# Get the arguments' separator
  sep = kwargs.get("sep") if ("sep" in kwargs) else " "

# Look for runtime error 
  error = False
  for a in args:
    if( type(a) == RuntimeError ):
      error = True
      pass

# Print the formated GeNESiS like message
  eva.EVA.python_print(sep.join(str(a) for a in args), error)

# Overwrite the print method  
builtins.print = custom_print

class CommonMultiSolver(Solver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonMultiSolver:
            _self = None
        else:
            _self = self
        _eva.CommonMultiSolver_swiginit(self, _eva.new_CommonMultiSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonMultiSolver
    get_classname = _swig_new_instance_method(_eva.CommonMultiSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonMultiSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonMultiSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonMultiSolver_get_shared)
    type = property(_eva.CommonMultiSolver_type_get, _eva.CommonMultiSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonMultiSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonMultiSolver_dereference)
    get = _swig_new_static_method(_eva.CommonMultiSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonMultiSolver_get_uuid)
    name = property(_eva.CommonMultiSolver_name_get, _eva.CommonMultiSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonMultiSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonMultiSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonMultiSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.CommonMultiSolver_build_comms)

# Register CommonMultiSolver in _eva:
_eva.CommonMultiSolver_swigregister(CommonMultiSolver)
CommonMultiSolver_get_shared = _eva.CommonMultiSolver_get_shared
CommonMultiSolver_unwrap = _eva.CommonMultiSolver_unwrap
CommonMultiSolver_dereference = _eva.CommonMultiSolver_dereference
CommonMultiSolver_get = _eva.CommonMultiSolver_get
CommonMultiSolver_gen_scheme = _eva.CommonMultiSolver_gen_scheme

class MultiSolver(CommonMultiSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == MultiSolver:
            _self = None
        else:
            _self = self
        _eva.MultiSolver_swiginit(self, _eva.new_MultiSolver(_self, ))
    __swig_destroy__ = _eva.delete_MultiSolver
    add_solver = _swig_new_instance_method(_eva.MultiSolver_add_solver)
    clone = _swig_new_instance_method(_eva.MultiSolver_clone)
    prepare = _swig_new_instance_method(_eva.MultiSolver_prepare)
    config_base = _swig_new_instance_method(_eva.MultiSolver_config_base)
    finalize = _swig_new_instance_method(_eva.MultiSolver_finalize)
    build = _swig_new_instance_method(_eva.MultiSolver_build)
    def __disown__(self):
        self.this.disown()
        _eva.disown_MultiSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.MultiSolver_build_comms)

# Register MultiSolver in _eva:
_eva.MultiSolver_swigregister(MultiSolver)

class CommonMatrixFreeSolver(Solver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonMatrixFreeSolver:
            _self = None
        else:
            _self = self
        _eva.CommonMatrixFreeSolver_swiginit(self, _eva.new_CommonMatrixFreeSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonMatrixFreeSolver
    get_classname = _swig_new_instance_method(_eva.CommonMatrixFreeSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonMatrixFreeSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonMatrixFreeSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonMatrixFreeSolver_get_shared)
    type = property(_eva.CommonMatrixFreeSolver_type_get, _eva.CommonMatrixFreeSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonMatrixFreeSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonMatrixFreeSolver_dereference)
    get = _swig_new_static_method(_eva.CommonMatrixFreeSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonMatrixFreeSolver_get_uuid)
    name = property(_eva.CommonMatrixFreeSolver_name_get, _eva.CommonMatrixFreeSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonMatrixFreeSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonMatrixFreeSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonMatrixFreeSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.CommonMatrixFreeSolver_build_comms)

# Register CommonMatrixFreeSolver in _eva:
_eva.CommonMatrixFreeSolver_swigregister(CommonMatrixFreeSolver)
CommonMatrixFreeSolver_get_shared = _eva.CommonMatrixFreeSolver_get_shared
CommonMatrixFreeSolver_unwrap = _eva.CommonMatrixFreeSolver_unwrap
CommonMatrixFreeSolver_dereference = _eva.CommonMatrixFreeSolver_dereference
CommonMatrixFreeSolver_get = _eva.CommonMatrixFreeSolver_get
CommonMatrixFreeSolver_gen_scheme = _eva.CommonMatrixFreeSolver_gen_scheme

class CommonMatrixBasedSolver(Solver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonMatrixBasedSolver:
            _self = None
        else:
            _self = self
        _eva.CommonMatrixBasedSolver_swiginit(self, _eva.new_CommonMatrixBasedSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonMatrixBasedSolver
    get_classname = _swig_new_instance_method(_eva.CommonMatrixBasedSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonMatrixBasedSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonMatrixBasedSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonMatrixBasedSolver_get_shared)
    type = property(_eva.CommonMatrixBasedSolver_type_get, _eva.CommonMatrixBasedSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonMatrixBasedSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonMatrixBasedSolver_dereference)
    get = _swig_new_static_method(_eva.CommonMatrixBasedSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonMatrixBasedSolver_get_uuid)
    name = property(_eva.CommonMatrixBasedSolver_name_get, _eva.CommonMatrixBasedSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonMatrixBasedSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonMatrixBasedSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonMatrixBasedSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.CommonMatrixBasedSolver_build_comms)

# Register CommonMatrixBasedSolver in _eva:
_eva.CommonMatrixBasedSolver_swigregister(CommonMatrixBasedSolver)
CommonMatrixBasedSolver_get_shared = _eva.CommonMatrixBasedSolver_get_shared
CommonMatrixBasedSolver_unwrap = _eva.CommonMatrixBasedSolver_unwrap
CommonMatrixBasedSolver_dereference = _eva.CommonMatrixBasedSolver_dereference
CommonMatrixBasedSolver_get = _eva.CommonMatrixBasedSolver_get
CommonMatrixBasedSolver_gen_scheme = _eva.CommonMatrixBasedSolver_gen_scheme

class MatrixFreeSolver(CommonMatrixFreeSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == MatrixFreeSolver:
            _self = None
        else:
            _self = self
        _eva.MatrixFreeSolver_swiginit(self, _eva.new_MatrixFreeSolver(_self, ))
    __swig_destroy__ = _eva.delete_MatrixFreeSolver
    prepare = _swig_new_instance_method(_eva.MatrixFreeSolver_prepare)
    process = _swig_new_instance_method(_eva.MatrixFreeSolver_process)
    start_comm = _swig_new_instance_method(_eva.MatrixFreeSolver_start_comm)
    wait_comm = _swig_new_instance_method(_eva.MatrixFreeSolver_wait_comm)
    set_architecture = _swig_new_instance_method(_eva.MatrixFreeSolver_set_architecture)
    config_base = _swig_new_instance_method(_eva.MatrixFreeSolver_config_base)
    initialize = _swig_new_instance_method(_eva.MatrixFreeSolver_initialize)
    stop_condition = _swig_new_instance_method(_eva.MatrixFreeSolver_stop_condition)
    phase1 = _swig_new_instance_method(_eva.MatrixFreeSolver_phase1)
    pack = _swig_new_instance_method(_eva.MatrixFreeSolver_pack)
    phase2 = _swig_new_instance_method(_eva.MatrixFreeSolver_phase2)
    unpack = _swig_new_instance_method(_eva.MatrixFreeSolver_unpack)
    phase3 = _swig_new_instance_method(_eva.MatrixFreeSolver_phase3)
    results = _swig_new_instance_method(_eva.MatrixFreeSolver_results)
    finalize = _swig_new_instance_method(_eva.MatrixFreeSolver_finalize)
    def __disown__(self):
        self.this.disown()
        _eva.disown_MatrixFreeSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.MatrixFreeSolver_build_comms)

# Register MatrixFreeSolver in _eva:
_eva.MatrixFreeSolver_swigregister(MatrixFreeSolver)

class MatrixBasedSolver(CommonMatrixBasedSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == MatrixBasedSolver:
            _self = None
        else:
            _self = self
        _eva.MatrixBasedSolver_swiginit(self, _eva.new_MatrixBasedSolver(_self, ))
    __swig_destroy__ = _eva.delete_MatrixBasedSolver
    prepare = _swig_new_instance_method(_eva.MatrixBasedSolver_prepare)
    process = _swig_new_instance_method(_eva.MatrixBasedSolver_process)
    solve = _swig_new_instance_method(_eva.MatrixBasedSolver_solve)
    stop_condition = _swig_new_instance_method(_eva.MatrixBasedSolver_stop_condition)
    define = _swig_new_instance_method(_eva.MatrixBasedSolver_define)
    config_base = _swig_new_instance_method(_eva.MatrixBasedSolver_config_base)
    assemble = _swig_new_instance_method(_eva.MatrixBasedSolver_assemble)
    results = _swig_new_instance_method(_eva.MatrixBasedSolver_results)
    finalize = _swig_new_instance_method(_eva.MatrixBasedSolver_finalize)
    def __disown__(self):
        self.this.disown()
        _eva.disown_MatrixBasedSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.MatrixBasedSolver_build_comms)

# Register MatrixBasedSolver in _eva:
_eva.MatrixBasedSolver_swigregister(MatrixBasedSolver)

class CommonMatrixFreeIOSolver(MatrixFreeSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonMatrixFreeIOSolver:
            _self = None
        else:
            _self = self
        _eva.CommonMatrixFreeIOSolver_swiginit(self, _eva.new_CommonMatrixFreeIOSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonMatrixFreeIOSolver
    get_classname = _swig_new_instance_method(_eva.CommonMatrixFreeIOSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonMatrixFreeIOSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonMatrixFreeIOSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonMatrixFreeIOSolver_get_shared)
    type = property(_eva.CommonMatrixFreeIOSolver_type_get, _eva.CommonMatrixFreeIOSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonMatrixFreeIOSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonMatrixFreeIOSolver_dereference)
    get = _swig_new_static_method(_eva.CommonMatrixFreeIOSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonMatrixFreeIOSolver_get_uuid)
    name = property(_eva.CommonMatrixFreeIOSolver_name_get, _eva.CommonMatrixFreeIOSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonMatrixFreeIOSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonMatrixFreeIOSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonMatrixFreeIOSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.CommonMatrixFreeIOSolver_build_comms)

# Register CommonMatrixFreeIOSolver in _eva:
_eva.CommonMatrixFreeIOSolver_swigregister(CommonMatrixFreeIOSolver)
CommonMatrixFreeIOSolver_get_shared = _eva.CommonMatrixFreeIOSolver_get_shared
CommonMatrixFreeIOSolver_unwrap = _eva.CommonMatrixFreeIOSolver_unwrap
CommonMatrixFreeIOSolver_dereference = _eva.CommonMatrixFreeIOSolver_dereference
CommonMatrixFreeIOSolver_get = _eva.CommonMatrixFreeIOSolver_get
CommonMatrixFreeIOSolver_gen_scheme = _eva.CommonMatrixFreeIOSolver_gen_scheme

class CommonLoopMultiSolver(MultiSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonLoopMultiSolver:
            _self = None
        else:
            _self = self
        _eva.CommonLoopMultiSolver_swiginit(self, _eva.new_CommonLoopMultiSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonLoopMultiSolver
    get_classname = _swig_new_instance_method(_eva.CommonLoopMultiSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonLoopMultiSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonLoopMultiSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonLoopMultiSolver_get_shared)
    type = property(_eva.CommonLoopMultiSolver_type_get, _eva.CommonLoopMultiSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonLoopMultiSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonLoopMultiSolver_dereference)
    get = _swig_new_static_method(_eva.CommonLoopMultiSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonLoopMultiSolver_get_uuid)
    name = property(_eva.CommonLoopMultiSolver_name_get, _eva.CommonLoopMultiSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonLoopMultiSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonLoopMultiSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonLoopMultiSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.CommonLoopMultiSolver_build_comms)

# Register CommonLoopMultiSolver in _eva:
_eva.CommonLoopMultiSolver_swigregister(CommonLoopMultiSolver)
CommonLoopMultiSolver_get_shared = _eva.CommonLoopMultiSolver_get_shared
CommonLoopMultiSolver_unwrap = _eva.CommonLoopMultiSolver_unwrap
CommonLoopMultiSolver_dereference = _eva.CommonLoopMultiSolver_dereference
CommonLoopMultiSolver_get = _eva.CommonLoopMultiSolver_get
CommonLoopMultiSolver_gen_scheme = _eva.CommonLoopMultiSolver_gen_scheme

class CommonChainedMultiSolver(MultiSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonChainedMultiSolver:
            _self = None
        else:
            _self = self
        _eva.CommonChainedMultiSolver_swiginit(self, _eva.new_CommonChainedMultiSolver(_self, ))
    __swig_destroy__ = _eva.delete_CommonChainedMultiSolver
    get_classname = _swig_new_instance_method(_eva.CommonChainedMultiSolver_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonChainedMultiSolver_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonChainedMultiSolver_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonChainedMultiSolver_get_shared)
    type = property(_eva.CommonChainedMultiSolver_type_get, _eva.CommonChainedMultiSolver_type_set)
    unwrap = _swig_new_static_method(_eva.CommonChainedMultiSolver_unwrap)
    dereference = _swig_new_static_method(_eva.CommonChainedMultiSolver_dereference)
    get = _swig_new_static_method(_eva.CommonChainedMultiSolver_get)
    get_uuid = _swig_new_instance_method(_eva.CommonChainedMultiSolver_get_uuid)
    name = property(_eva.CommonChainedMultiSolver_name_get, _eva.CommonChainedMultiSolver_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonChainedMultiSolver_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonChainedMultiSolver_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonChainedMultiSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.CommonChainedMultiSolver_build_comms)

# Register CommonChainedMultiSolver in _eva:
_eva.CommonChainedMultiSolver_swigregister(CommonChainedMultiSolver)
CommonChainedMultiSolver_get_shared = _eva.CommonChainedMultiSolver_get_shared
CommonChainedMultiSolver_unwrap = _eva.CommonChainedMultiSolver_unwrap
CommonChainedMultiSolver_dereference = _eva.CommonChainedMultiSolver_dereference
CommonChainedMultiSolver_get = _eva.CommonChainedMultiSolver_get
CommonChainedMultiSolver_gen_scheme = _eva.CommonChainedMultiSolver_gen_scheme

class MatrixFreeIOSolver(CommonMatrixFreeIOSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == MatrixFreeIOSolver:
            _self = None
        else:
            _self = self
        _eva.MatrixFreeIOSolver_swiginit(self, _eva.new_MatrixFreeIOSolver(_self, ))
    __swig_destroy__ = _eva.delete_MatrixFreeIOSolver
    config_base = _swig_new_instance_method(_eva.MatrixFreeIOSolver_config_base)
    phase2 = _swig_new_instance_method(_eva.MatrixFreeIOSolver_phase2)
    start_IO = _swig_new_instance_method(_eva.MatrixFreeIOSolver_start_IO)
    wait_IO = _swig_new_instance_method(_eva.MatrixFreeIOSolver_wait_IO)
    phase2_1 = _swig_new_instance_method(_eva.MatrixFreeIOSolver_phase2_1)
    pack_IO = _swig_new_instance_method(_eva.MatrixFreeIOSolver_pack_IO)
    phase2_2 = _swig_new_instance_method(_eva.MatrixFreeIOSolver_phase2_2)
    unpack_IO = _swig_new_instance_method(_eva.MatrixFreeIOSolver_unpack_IO)
    phase2_3 = _swig_new_instance_method(_eva.MatrixFreeIOSolver_phase2_3)
    def __disown__(self):
        self.this.disown()
        _eva.disown_MatrixFreeIOSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.MatrixFreeIOSolver_build_comms)

# Register MatrixFreeIOSolver in _eva:
_eva.MatrixFreeIOSolver_swigregister(MatrixFreeIOSolver)

class LoopMultiSolver(CommonLoopMultiSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == LoopMultiSolver:
            _self = None
        else:
            _self = self
        _eva.LoopMultiSolver_swiginit(self, _eva.new_LoopMultiSolver(_self, ))
    __swig_destroy__ = _eva.delete_LoopMultiSolver
    config_base = _swig_new_instance_method(_eva.LoopMultiSolver_config_base)
    process = _swig_new_instance_method(_eva.LoopMultiSolver_process)
    stop_condition = _swig_new_instance_method(_eva.LoopMultiSolver_stop_condition)
    def __disown__(self):
        self.this.disown()
        _eva.disown_LoopMultiSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.LoopMultiSolver_build_comms)

# Register LoopMultiSolver in _eva:
_eva.LoopMultiSolver_swigregister(LoopMultiSolver)

class ChainedMultiSolver(CommonChainedMultiSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == ChainedMultiSolver:
            _self = None
        else:
            _self = self
        _eva.ChainedMultiSolver_swiginit(self, _eva.new_ChainedMultiSolver(_self, ))
    __swig_destroy__ = _eva.delete_ChainedMultiSolver
    config_base = _swig_new_instance_method(_eva.ChainedMultiSolver_config_base)
    start = _swig_new_instance_method(_eva.ChainedMultiSolver_start)
    def __disown__(self):
        self.this.disown()
        _eva.disown_ChainedMultiSolver(self)
        return weakref.proxy(self)
    build_comms = _swig_new_instance_method(_eva.ChainedMultiSolver_build_comms)

# Register ChainedMultiSolver in _eva:
_eva.ChainedMultiSolver_swigregister(ChainedMultiSolver)

class CommonGPUArchitecture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonGPUArchitecture:
            _self = None
        else:
            _self = self
        _eva.CommonGPUArchitecture_swiginit(self, _eva.new_CommonGPUArchitecture(_self, ))
    __swig_destroy__ = _eva.delete_CommonGPUArchitecture
    get_classname = _swig_new_instance_method(_eva.CommonGPUArchitecture_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonGPUArchitecture_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonGPUArchitecture_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonGPUArchitecture_get_shared)
    type = property(_eva.CommonGPUArchitecture_type_get, _eva.CommonGPUArchitecture_type_set)
    unwrap = _swig_new_static_method(_eva.CommonGPUArchitecture_unwrap)
    dereference = _swig_new_static_method(_eva.CommonGPUArchitecture_dereference)
    get = _swig_new_static_method(_eva.CommonGPUArchitecture_get)
    get_uuid = _swig_new_instance_method(_eva.CommonGPUArchitecture_get_uuid)
    name = property(_eva.CommonGPUArchitecture_name_get, _eva.CommonGPUArchitecture_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonGPUArchitecture_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonGPUArchitecture_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonGPUArchitecture(self)
        return weakref.proxy(self)

# Register CommonGPUArchitecture in _eva:
_eva.CommonGPUArchitecture_swigregister(CommonGPUArchitecture)
CommonGPUArchitecture_get_shared = _eva.CommonGPUArchitecture_get_shared
CommonGPUArchitecture_unwrap = _eva.CommonGPUArchitecture_unwrap
CommonGPUArchitecture_dereference = _eva.CommonGPUArchitecture_dereference
CommonGPUArchitecture_get = _eva.CommonGPUArchitecture_get
CommonGPUArchitecture_gen_scheme = _eva.CommonGPUArchitecture_gen_scheme

class CommonGPArchitecture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CommonGPArchitecture:
            _self = None
        else:
            _self = self
        _eva.CommonGPArchitecture_swiginit(self, _eva.new_CommonGPArchitecture(_self, ))
    __swig_destroy__ = _eva.delete_CommonGPArchitecture
    get_classname = _swig_new_instance_method(_eva.CommonGPArchitecture_get_classname)
    get_metadata_path = _swig_new_instance_method(_eva.CommonGPArchitecture_get_metadata_path)
    shared_from_this = _swig_new_instance_method(_eva.CommonGPArchitecture_shared_from_this)
    get_shared = _swig_new_static_method(_eva.CommonGPArchitecture_get_shared)
    type = property(_eva.CommonGPArchitecture_type_get, _eva.CommonGPArchitecture_type_set)
    unwrap = _swig_new_static_method(_eva.CommonGPArchitecture_unwrap)
    dereference = _swig_new_static_method(_eva.CommonGPArchitecture_dereference)
    get = _swig_new_static_method(_eva.CommonGPArchitecture_get)
    get_uuid = _swig_new_instance_method(_eva.CommonGPArchitecture_get_uuid)
    name = property(_eva.CommonGPArchitecture_name_get, _eva.CommonGPArchitecture_name_set)
    get_scheme = _swig_new_instance_method(_eva.CommonGPArchitecture_get_scheme)
    gen_scheme = _swig_new_static_method(_eva.CommonGPArchitecture_gen_scheme)
    def __disown__(self):
        self.this.disown()
        _eva.disown_CommonGPArchitecture(self)
        return weakref.proxy(self)

# Register CommonGPArchitecture in _eva:
_eva.CommonGPArchitecture_swigregister(CommonGPArchitecture)
CommonGPArchitecture_get_shared = _eva.CommonGPArchitecture_get_shared
CommonGPArchitecture_unwrap = _eva.CommonGPArchitecture_unwrap
CommonGPArchitecture_dereference = _eva.CommonGPArchitecture_dereference
CommonGPArchitecture_get = _eva.CommonGPArchitecture_get
CommonGPArchitecture_gen_scheme = _eva.CommonGPArchitecture_gen_scheme

class GPArchitecture(CommonGPArchitecture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == GPArchitecture:
            _self = None
        else:
            _self = self
        _eva.GPArchitecture_swiginit(self, _eva.new_GPArchitecture(_self, ))
    __swig_destroy__ = _eva.delete_GPArchitecture
    create = _swig_new_static_method(_eva.GPArchitecture_create)
    get_hardware_info = _swig_new_instance_method(_eva.GPArchitecture_get_hardware_info)
    def __disown__(self):
        self.this.disown()
        _eva.disown_GPArchitecture(self)
        return weakref.proxy(self)

# Register GPArchitecture in _eva:
_eva.GPArchitecture_swigregister(GPArchitecture)
ARCHITECTURE_CORES = cvar.ARCHITECTURE_CORES
ARCHITECTURE_CPUS = cvar.ARCHITECTURE_CPUS
GPArchitecture_create = _eva.GPArchitecture_create

class GPUArchitecture(CommonGPUArchitecture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == GPUArchitecture:
            _self = None
        else:
            _self = self
        _eva.GPUArchitecture_swiginit(self, _eva.new_GPUArchitecture(_self, ))
    __swig_destroy__ = _eva.delete_GPUArchitecture
    memory = property(_eva.GPUArchitecture_memory_get, _eva.GPUArchitecture_memory_set)
    capability = property(_eva.GPUArchitecture_capability_get, _eva.GPUArchitecture_capability_set)
    create = _swig_new_static_method(_eva.GPUArchitecture_create)
    get_hardware_info = _swig_new_instance_method(_eva.GPUArchitecture_get_hardware_info)
    def __disown__(self):
        self.this.disown()
        _eva.disown_GPUArchitecture(self)
        return weakref.proxy(self)

# Register GPUArchitecture in _eva:
_eva.GPUArchitecture_swigregister(GPUArchitecture)
ARCHITECTURE_CAPABILITY = cvar.ARCHITECTURE_CAPABILITY
ARCHITECTURE_MEMORY = cvar.ARCHITECTURE_MEMORY
GPUArchitecture_create = _eva.GPUArchitecture_create

class EVAManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    get = _swig_new_static_method(_eva.EVAManager_get)
    get_communication = _swig_new_instance_method(_eva.EVAManager_get_communication)
    restrict_architectures = _swig_new_instance_method(_eva.EVAManager_restrict_architectures)
    get_devices_number = _swig_new_instance_method(_eva.EVAManager_get_devices_number)
    evas = property(_eva.EVAManager_evas_get, _eva.EVAManager_evas_set)
    metaNames = property(_eva.EVAManager_metaNames_get, _eva.EVAManager_metaNames_set)
    archsinfo = property(_eva.EVAManager_archsinfo_get, _eva.EVAManager_archsinfo_set)
    linksinfo = property(_eva.EVAManager_linksinfo_get, _eva.EVAManager_linksinfo_set)
    archs = property(_eva.EVAManager_archs_get, _eva.EVAManager_archs_set)
    timers = property(_eva.EVAManager_timers_get, _eva.EVAManager_timers_set)
    __swig_destroy__ = _eva.delete_EVAManager

# Register EVAManager in _eva:
_eva.EVAManager_swigregister(EVAManager)
EVAMANAGER_SCHEMES = cvar.EVAMANAGER_SCHEMES
EVAMANAGER_ARCHITECTURES = cvar.EVAMANAGER_ARCHITECTURES
EVAMANAGER_LINKS = cvar.EVAMANAGER_LINKS
EVAManager_get = _eva.EVAManager_get

class EVA(CommonEVA):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):

        import os 
        with open(".genesis_location", "w") as text_file:
          text_file.write("%s" % os.path.dirname(eva.__file__))


        if self.__class__ == EVA:
            _self = None
        else:
            _self = self
        _eva.EVA_swiginit(self, _eva.new_EVA(_self, ))

           # Import the Python platform module
        import platform as pt

        # Multi-threading is not supported on Python codes
        self.multithread = False

        # The platform is Python  
        self.platform = str("Python " + pt.python_version()+ " '"+ pt.system() \
        + " " + pt.python_implementation()+ "'")



    config = _swig_new_instance_method(_eva.EVA_config)
    start = _swig_new_instance_method(_eva.EVA_start)
    get_results = _swig_new_instance_method(_eva.EVA_get_results)
    free_results = _swig_new_instance_method(_eva.EVA_free_results)
    finish = _swig_new_instance_method(_eva.EVA_finish)
    get_EVAManager = _swig_new_instance_method(_eva.EVA_get_EVAManager)
    archs = property(_eva.EVA_archs_get, _eva.EVA_archs_set)
    ndevices = property(_eva.EVA_ndevices_get, _eva.EVA_ndevices_set)
    multithread = property(_eva.EVA_multithread_get, _eva.EVA_multithread_set)
    platform = property(_eva.EVA_platform_get, _eva.EVA_platform_set)
    python_print = _swig_new_static_method(_eva.EVA_python_print)
    add_solver = _swig_new_instance_method(_eva.EVA_add_solver)
    set_mesh = _swig_new_instance_method(_eva.EVA_set_mesh)
    __swig_destroy__ = _eva.delete_EVA
    def __disown__(self):
        self.this.disown()
        _eva.disown_EVA(self)
        return weakref.proxy(self)

# Register EVA in _eva:
_eva.EVA_swigregister(EVA)
EVA_python_print = _eva.EVA_python_print



  # Import some useful packages
import json
import numpy as np
import pickle
import codecs
import io
import sys
import traceback

# Dictionary for keeping objects instances on a global scope 
pobjects = {}

# Class able to create an object from itself.
class Clonable():
  def clone(self):
    s = self.__class__()
# print("Clonning solver ", self.get_uuid(), "on", s.get_uuid() )
    pobjects[s.get_uuid()] = s
    return s

def pack_data (self, neighbor, data):
# Redefine the pack_data method for serializing external data
  try:
# Try to pack data as a known type
    self._pack_data(neighbor, data)
  except Exception as e:
    try:
# Serialize Numpy object
      if type(data).__module__ == np.__name__:
        memfile = io.BytesIO()
        np.save(memfile, data)
        memfile.seek(0)
        self._pack_data(neighbor, json.dumps(memfile.read().decode('latin-1')))
      else:
# Serialize a known Python object
#self._pack_data(neighbor, json.dumps(data))
        self.pack_data(neighbor, codecs.encode(pickle.dumps(data), "base64").decode())
    except Exception as e1:
       raise Exception("Exception on pack_data: " +  str(e1))

def unpack_data (self, neighbor, dtype):
# Redefine the unpack_data method for deserializing external data
  try:
# Try to unpack data as a known type
    return self._unpack_data(neighbor, dtype)
  except Exception as e:
    try:
      tmp = self._unpack_data(neighbor, "")

# Deserialize Numpy object
      if type(dtype).__module__ == np.__name__:
        memfile = io.BytesIO()
        memfile.write(json.loads(tmp).encode('latin-1'))
        memfile.seek(0)
        return np.load(memfile)
      else:
# Deserialize a known Python object
#return json.loads(tmp)
        return pickle.loads(codecs.decode(tmp.encode(), "base64"))
    except Exception as e1:
      raise Exception("Exception on unpack_data: " +  str(e1))

CommonChainedMultiSolver.pack_data = pack_data
CommonLoopMultiSolver.pack_data = pack_data
CommonMatrixFreeIOSolver.pack_data = pack_data
CommonMatrixFreeSolver.pack_data = pack_data
CommonMatrixBasedSolver.pack_data = pack_data

CommonChainedMultiSolver.unpack_data = unpack_data
CommonLoopMultiSolver.unpack_data = unpack_data
CommonMatrixFreeIOSolver.unpack_data = unpack_data
CommonMatrixFreeSolver.unpack_data = unpack_data
CommonMatrixBasedSolver.unpack_data = unpack_data




