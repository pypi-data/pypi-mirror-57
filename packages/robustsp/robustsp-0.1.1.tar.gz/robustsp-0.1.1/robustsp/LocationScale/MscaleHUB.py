'''
Mscale_HUB computes Huber's M-estimate of scale.

   INPUTS: 
           y: real valued data vector of size N x 1
           c: tuning constant c>=0 . default = 1.345
               default tuning for 95 percent efficiency under the Gaussian model
           max_iters: Number of iterations. default = 1000
           tol_err: convergence error tolerance. default = 1e-5
           path: default None, string. path to random samples.
               if not specified, the samples will by generated by the numpy rng.
   OUTPUT:  
           sigma_hat: Huber's M-estimate of scale
'''
import numpy as np
import random
from robustsp.AuxiliaryFunctions.madn import madn
from robustsp.AuxiliaryFunctions.whub import whub
from robustsp.AuxiliaryFunctions.rhohub import rhohub
import pkg_resources


def MscaleHUB(y,c=1.345, max_iters = 1000, tol_err = 1e-5):
    y = np.array(y) # ensure that y is a ndarray
    path = pkg_resources.resource_filename('robustsp', 'data/u.mat')
    # initial scale estimate
    sigma_n = madn(y)
    
    # subtract previously computed location
    mu_hat = np.median(y)
    y = y-mu_hat
    
    # length of samples
    N = len(y)
    
    # consistency with the standard deviation at the Gaussian   
    import scipy.io
    u = scipy.io.loadmat(path,struct_as_record=False)
    u = u['u']

    delta = np.mean(rhohub(u,c))
    
    n=0
    while n<=max_iters:
        w_n = whub(np.abs(y)/sigma_n,c)
        sigma_n_plus1 = np.sqrt(1/(N*delta)*np.sum(w_n * np.square(y)))
        if np.abs(sigma_n_plus1 / (sigma_n -1)) > tol_err:
            sigma_n = sigma_n_plus1
            n = n+1
        else:
            break
    
    return sigma_n