'''
Mscale_TUK computes Tukey's M-estimate of scale.


   INPUTS: 
           y: real valued data vector of size N x 1
           c: tuning constant c>=0 . default = 4.685
               default tuning for 95 percent efficiency under the Gaussian model
           max_iters: Number of iterations. default = 1000
           tol_err: convergence error tolerance. default = 1e-5
           path: default None, string. path to Matlab generated random samples.
               if not specified, the samples will by generated by the numpy rng.
   OUTPUT:  
           sigma_hat: Huber's M-estimate of scale
'''
import numpy as np
import random
from robustsp.AuxiliaryFunctions.madn import madn
from robustsp.AuxiliaryFunctions.wtuk import wtuk
from robustsp.AuxiliaryFunctions.rhotuk import rhotuk
import pkg_resources
def MscaleTUK(y,c=4.685, max_iters = 1000, tol_err = 1e-5):
    y = np.array(y) # ensure that y is a ndarray
    path = pkg_resources.resource_filename('robustsp', 'data/u.mat')
    # initial scale estimate
    sigma_n = madn(y)
    
    # subtract previously computed location
    mu_hat = np.median(y)
    y = y-mu_hat
    
    # length of samples
    N = len(y)
    
    # consistency with the standard deviation at the Gaussian
    import scipy.io
    u = scipy.io.loadmat(path,struct_as_record=False)
    u = u['u']
        
    delta = np.mean(rhotuk(u,c))
    
    n=0
    while n<=max_iters:
        w_n = wtuk(np.absolute(y)/sigma_n,c)
        sigma_n_plus1 = np.sqrt(1/(N*delta)*np.sum(w_n * y**2))
        if np.absolute(sigma_n_plus1 / (sigma_n -1)) > tol_err:
            sigma_n = sigma_n_plus1
            n = n+1
        else:
            break
    
    return sigma_n
