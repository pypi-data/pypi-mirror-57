# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['pyrate_limiter']

package_data = \
{'': ['*'], 'pyrate_limiter': ['engines/*']}

entry_points = \
{'console_scripts': ['lint = scripts:lint', 'test = scripts:test']}

setup_kwargs = {
    'name': 'pyrate-limiter',
    'version': '1.1.0',
    'description': 'Python Rate-Limiter using Leaky-Bucket Algorimth Family',
    'long_description': '<img align="left" width="95" height="120" src="https://raw.githubusercontent.com/vutran1710/PyrateLimiter/master/img/log.png">\n\n# PyrateLimiter\nThe request rate limiter using Leaky-bucket algorithm\n\n[![PyPI version](https://badge.fury.io/py/pyrate-limiter.svg)](https://badge.fury.io/py/pyrate-limiter)\n[![Python 3.7](https://img.shields.io/badge/python-3.7-blue.svg)](https://www.python.org/downloads/release/python-370/)\n[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://github.com/vutran1710/PyrateLimiter/graphs/commit-activity)\n[![PyPI license](https://img.shields.io/pypi/l/ansicolortags.svg)](https://pypi.python.org/pypi/pyrate-limiter/)\n[![HitCount](http://hits.dwyl.io/vutran1710/PyrateLimiter.svg)](http://hits.dwyl.io/vutran1710/PyrateLimiter)\n\n<br>\n\n## Introduction\nThis module can be used to apply rate-limit for API request, using `leaky-bucket` algorithm. User defines `window`\nduration and the limit of function calls within such interval.\n\n- To hold the state of the Bucket, you can use `LocalBucket` as internal bucket.\n- To use PyrateLimiter with `Redis`,  `redis-py` is required to be installed.\n- It is also possible to use your own Bucket implementation, by extending `AbstractBucket` from `pyrate_limiter.core`\n\n\n## Installation\nUsing pip/pipenv/poetry, whatever that works for your\n\n``` shell\n$ pip install pyrate-limiter\n```\n\n\n## API\nOne of the most pleasing features of this lib is that it is meant to be very extensible. People\'s efforts to solve the rate-limiting\nproblem have so far led to the introduction of a few variations of the **leaky-bucket** algorithm. The idea behind this is project is that\nyou can extend the main core data-structure that powers every member of this algorithm family.\n\n#### AbstractBucket\n```python\nfrom pyrate_limiter.core import AbstractBucket\n```\nAbstractBucket is a python abstract class that provides the Interface for, well, a `queue`. The algorithms provided in\n`pyrate_limiter.core` all make use of this data-structure. A concrete implementation of this abstract class must includes 4\nmethods of the *bucket* instance.\n\n``` python\nclass AbstractBucket(ABC):\n    """An abstract class for Bucket as Queue"""\n\n    __values__ = []\n\n    @abstractmethod\n    def append(self, item) -> None:\n        """Add single item to the queue\n        """\n    @abstractmethod\n    def values(self) -> List:\n        """Return queue values\n        """\n    @abstractmethod\n    def update(self, new_list: List) -> None:\n        """Completely replace the existing queue with a new one\n        """\n    def getlen(self) -> int:\n        """Return the current queue\'s length\n        """\n        return len(self.__values__)\n```\n\nDue to personal needs, 2 ready-use implementations with [Redis](https://github.com/vutran1710/PyrateLimiter/blob/master/pyrate_limiter/engines/redis.py) and [Application Local State](https://github.com/vutran1710/PyrateLimiter/blob/master/pyrate_limiter/engines/local.py) are provided.\n\nWhen designing a rate-limiting service that depends on a different type of data-store, like `Postgres` or `Mysql`,\nthe user can write their own AbstractBucket implementation that fits their needs.\n\n## Usage\n\n``` python\nfrom pyrate_limiter.core import TokenBucketLimiter, LeakyBucketLimiter\nfrom pyrate_limiter.engines.redis import RedisBucket\nfrom pyrate_limiter.engines.local import LocalBucket\nfrom pyrate_limiter.exceptions import BucketFullException\n\n# Init redis bucket\nbucket = RedisBucket(\'redis-url\', hash=\'some-hash\', key=\'some-key\')\n\n# Create Limiter using Token-Bucket Algorithm\n# Maximum 10 items over 60 seconds\nlimiter = TokenBucketLimiter(bucket, capacity=10, window=60)\nlimiter.queue.config(key=\'change-key\')\n# Process an item\ntry:\n    limiter.process(\'some-json-serializable-value\')\n    print(\'Item allowed to pass through\')\nexcept BucketFullException:\n    print(\'Bucket is full\')\n    # do something\n\n\n\n# Similarly, using Leaky-Bucket Algorithm\nlimiter = LeakyBucketLimiter(bucket, capacity=5, window=6)\nlimiter.queue.config(key=\'change-key\')\n# Process an item\ntry:\n    # For LeakyBucketLimiter using the similar process method, only\n    # different in naming...\n    limiter.append(\'some-json-serializable-value\')\n    print(\'Item allowed to pass through\')\nexcept BucketFullException:\n    print(\'Bucket is full\')\n    # do something\n\n\n# If using LocalBucket, the instantiation is even simpler\nbucket = LocalBucket(initial_values=some_list_type_value)\n```\n\n\n## Understanding the Algorithms\n\n#### LeakyBucket with Sliding-Window Algorithm\nLeakyBucket with Sliding-Window Algorithm is a capped bucket of items. Every item expires after {window} time, making room for later items to go in.\n\nItem\'s expiring-rate is {window} time.\nUsing a simple timeline model, we can describe it as follow\n```\nTIME <<----------[===========WINDOW===========]--------------------------------<<\nREQS >>--- <req> ---- <req> ---- <req> ---- <req> ---- <req> ---- <req> ------->>\n```\n\n#### TokenBucket\nTokenBucket with Fixed-Window Algorithm can be described as multiple groups of Going-In-Items that do not exceed the Bucket Capacity running into the Bucket with fixed-intervals between groups.\n\nThe bucket\'s queue resets if the interval between 2 items is larger or equal to {window} time.\n\n```\n>>-- [x items] ----- (window) ------ [y items] ------ (window) ------ [z items] --->>\neg:  3reqs/3s         <5sec>          2reqs/1s         <5sec>          3reqs/3s\n```\n\n## Testing\nSimple as it should be, given you have [poetry](https://poetry.eustace.io/) installed...\n\n``` shell\n$ poetry run test\n```\n\nCICD flow is not currently set up since I dont have much time, but FYI, the `coverage` is decent enought IMO...\n\n``` shell\ntests/test_leaky_bucket.py::test_bucket_overloaded PASSED\ntests/test_leaky_bucket.py::test_bucket_cooldown PASSED\ntests/test_local_engine.py::test_invalid_initials PASSED\ntests/test_local_engine.py::test_leaky_bucket_overloaded PASSED\ntests/test_local_engine.py::test_leaky_bucket_cooldown PASSED\ntests/test_local_engine.py::test_token_bucket_overloaded PASSED\ntests/test_local_engine.py::test_token_bucket_cooldown PASSED\ntests/test_redis_engine.py::test_bucket_overloaded PASSED\ntests/test_redis_engine.py::test_bucket_cooldown PASSED\ntests/test_redis_engine.py::test_normalize_redis_value PASSED\ntests/test_redis_engine.py::test_token_bucket_overloaded PASSED\ntests/test_redis_engine.py::test_token_bucket_cooldown PASSED\ntests/test_token_bucket.py::test_bucket_overloaded PASSED\ntests/test_token_bucket.py::test_bucket_cooldown PASSED\n\n---------- coverage: platform darwin, python 3.7.5-final-0 -----------\nName                                Stmts   Miss  Cover\n-------------------------------------------------------\npyrate_limiter/__init__.py              1      0   100%\npyrate_limiter/basic_algorithm.py      45      0   100%\npyrate_limiter/core.py                 63      3    95%\npyrate_limiter/engines/local.py        14      0   100%\npyrate_limiter/engines/redis.py        33      1    97%\npyrate_limiter/exceptions.py            5      0   100%\n-------------------------------------------------------\nTOTAL                                 161      4    98%\n```\n',
    'author': 'vutr',
    'author_email': 'me@vutr.io',
    'url': 'https://github.com/vutran1710/PyrateLimiter',
    'packages': packages,
    'package_data': package_data,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
