# -*- coding: utf-8 -*-
# Copyright 2019 Julien Sobrier
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

""" Version 1.0.0

Python module for Thumbalizr (https://thumbalizr.com/), a web service to create website screenshots.

Thumbalizr (https://thumbalizr.com/) is a web service to easily embed live screenshots of any URL in your website. Thumbalizr has full support for Flash, JavaScript, CSS, & HTML5.

The source code is available on github at https://github.com/juliensobrier/thumbalizr-python  """

import hashlib
import time
import urllib
from urllib.request import urlopen

class Thumbalizr(object):
    def __init__(self, key='', secret='', debug=0, base='https://api.thumbalizr.com/api/v1/embed'):
        """ Create a new Thumbalizr object. You must pass your API key (go to you Dashboard to find your API key, https://browshot.com/dashboard).

        Arguments:
            key:  Thubalizr Embed API key.
            secret: Thumbalizr secret
            debug: Set to 1 to print debug output to the standard output. 0 (disabled) by default.
            base: Base URL for all API requests. You should use the default base provided by the library.
        """
        self.key = key
        self.secret = secret
        self.base = base
        self.debug = debug

    def url(self, url='', parameters={}):
        """ Generate the URL of the Thumbalizr image

        Arguments:
             url (required): URL of the website to create a screenshot of.
             parameters (optional): optional API parameters
        """ 
        query = 'url=' + urllib.parse.quote_plus(url)

        for key, value in parameters.items():
             query += '&' + key + '=' + urllib.parse.quote_plus(str(value))
  
        string = query + self.secret
        token = hashlib.md5(string.encode('utf-8')).hexdigest()
  
        return "%s/%s/%s/?%s" % (self.base, self.key, token, query)

    def download(self, url, file =''):
        """ Download the Thumbalizr URL generated by url()
        
            Returns an array:
               Status of the screenshot: OK, FAILED or QUEUED
               Image content  (if file is not specified) or the file name provided. This value is empty is the screenshot failed or is not finished (QUEUED)
    
            Arguments:
                url (required): Thumbalizr url
                file (optional): local filename to tave the image file.
        """
        try:
            response = urlopen(url)

            return [response.getheader('X-Thumbalizr-Status'), response.read()]
        except urllib.error.HTTPError as e:
            if self.debug:
              print(e.headers['X-Thumbalizr-Error'])
            return [e.headers['X-Thumbalizr-Status'], '']
        except Exception as e:
            if self.debug:
              print(e.headers['X-Thumbalizr-Error'])
            return [e.headers['X-Thumbalizr-Status'], '']

    def download_wait(self, url, file ='', delay=10):
        """ Download the Thumbalizr URL generated by url(). Unline download(), this function waits for the screenshot to be finished or failed.
        
            Returns an array:
               Status of the screenshot: OK or FAILED
               Image content  (if file is not specified) or the file name provided. This value is empty is the screenshot failed 
    
            Arguments:
                url (required): Thumbalizr url
                file (optional): local filename to tave the image file.
                delay (optional): number of secodns to wait between 2 attempts. 10 seconds by default.
        """
        results = self.download(url, file)
        
        while results[0] == 'QUEUED':
            time.sleep(delay)
            if self.debug:
              print("Status: " + results[0])
            results = self.download(url, file)
        
        return results