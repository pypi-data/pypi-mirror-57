
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Technical Overview &#8212; pyMOR v2019.2rc0+680.g9bf3f73a.dirty Manual</title>
    <link rel="stylesheet" href="_static/pymor.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Environment Variables" href="environment.html" />
    <link rel="prev" title="Getting started" href="getting_started.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="environment.html" title="Environment Variables"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="Getting started"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyMOR v2019.2rc0+680.g9bf3f73a.dirty Manual</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="technical-overview">
<span id="id1"></span><h1>Technical Overview<a class="headerlink" href="#technical-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="three-central-classes">
<h2>Three Central Classes<a class="headerlink" href="#three-central-classes" title="Permalink to this headline">¶</a></h2>
<p>From a bird’s eye perspective, pyMOR is a collection of generic algorithms
operating on objects of the following types:</p>
<dl>
<dt><a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a></dt><dd><p>Vector arrays are ordered collections of vectors. Each vector of the array
must be of the same <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.dim" title="pymor.vectorarrays.interfaces.VectorArrayInterface.dim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dimension</span></code></a>. Vectors can be <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.copy" title="pymor.vectorarrays.interfaces.VectorArrayInterface.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copied</span></code></a> to a new array,
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.append" title="pymor.vectorarrays.interfaces.VectorArrayInterface.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">appended</span></code></a> to an existing array or <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.__delitem__" title="pymor.vectorarrays.interfaces.VectorArrayInterface.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deleted</span></code></a> from the array. Basic linear
algebra operations can be performed on the vectors of the
array: vectors can be <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.scal" title="pymor.vectorarrays.interfaces.VectorArrayInterface.scal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scaled</span></code></a> in-place, the BLAS <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.axpy" title="pymor.vectorarrays.interfaces.VectorArrayInterface.axpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">axpy</span></code></a> operation is
supported and <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.inner" title="pymor.vectorarrays.interfaces.VectorArrayInterface.inner"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner</span> <span class="pre">products</span></code></a> between vectors can be formed. Linear
combinations of vectors can be formed using the <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.lincomb" title="pymor.vectorarrays.interfaces.VectorArrayInterface.lincomb"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lincomb</span></code></a> method. Moreover,
various norms can be computed and selected <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.dofs" title="pymor.vectorarrays.interfaces.VectorArrayInterface.dofs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dofs</span></code></a> of the vectors can
be extracted for <a class="reference internal" href="generated/pymor.algorithms.html#module-pymor.algorithms.ei" title="pymor.algorithms.ei"><code class="xref py py-mod docutils literal notranslate"><span class="pre">empirical</span> <span class="pre">interpolation</span></code></a>.
To act on subsets of vectors of an array, arrays can be <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface.__getitem__" title="pymor.vectorarrays.interfaces.VectorArrayInterface.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexed</span></code></a> with an
integer, a list of integers or a slice, in each case returning a new
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a> which acts as a modifiable view onto the respective vectors in
the original array. As a convenience, many of Python’s math operators are
implemented in terms of the interface methods.</p>
<p>Note that there is not the notion of a single vector in pyMOR. The main
reason for this design choice is to take advantage of vectorized
implementations like <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.numpy.NumpyVectorArray" title="pymor.vectorarrays.numpy.NumpyVectorArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NumpyVectorArray</span></code></a> which internally store the vectors
as two-dimensional <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.17)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">NumPy</span></code></a> arrays. As an example, the application of a
linear matrix based operator to an array via the <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.apply" title="pymor.operators.interfaces.OperatorInterface.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply</span></code></a> method boils down
to a call to <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.17)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">NumPy</span></code></a>’s optimized <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dot.html#numpy.ndarray.dot" title="(in NumPy v1.17)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dot</span></code></a> method. If
there were only lists of vectors in pyMOR, the above matrix-matrix
multiplication would have to be expressed by a loop of matrix-vector
multiplications.  However, when working with external solvers, vector
arrays will often be given as lists of individual vector objects. For this
use-case we provide <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.list.ListVectorArray" title="pymor.vectorarrays.list.ListVectorArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ListVectorArray</span></code></a>, a <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a> based on a Python
list of vectors.</p>
<p>Associated to each vector array is a <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a> which acts as a
factory for new arrays of a given type.  New vector arrays can be created
using the <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface.zeros" title="pymor.vectorarrays.interfaces.VectorSpaceInterface.zeros"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zeros</span></code></a> and <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface.empty" title="pymor.vectorarrays.interfaces.VectorSpaceInterface.empty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">empty</span></code></a> methods. To wrap the raw objects of the
underlying linear algebra backend into a new <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a>, <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface.make_array" title="pymor.vectorarrays.interfaces.VectorSpaceInterface.make_array"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_array</span></code></a>
is used.</p>
<p>The data needed to define a new <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a> largely depends on the
implementation of the underlying backend. For <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.numpy.NumpyVectorSpace" title="pymor.vectorarrays.numpy.NumpyVectorSpace"><code class="xref py py-func docutils literal notranslate"><span class="pre">NumpyVectorSpace</span></code></a>, the
only required datum is the dimension of the contained vectors.
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpaces</span></code></a> for other backends could, e.g., hold a socket for
communication with a specific PDE solver instance. Additionally,
each <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a> has a string <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface.id" title="pymor.vectorarrays.interfaces.VectorSpaceInterface.id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id</span></code></a>, defaulting to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which
is used to signify the mathematical identity of the given space.</p>
<p>Two arrays in pyMOR are compatible (e.g. can be added) if they are from
the same <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a>. If a <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a> is contained in a given
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a> can be tested with the <code class="docutils literal notranslate"><span class="pre">in</span></code> operator.</p>
</dd>
<dt><a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a></dt><dd><p>The main property of operators in pyMOR is that they can be <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.apply" title="pymor.operators.interfaces.OperatorInterface.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">applied</span></code></a> to
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a> resulting in a new <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a>. For this operation to be
allowed, the operator’s <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.source" title="pymor.operators.interfaces.OperatorInterface.source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source</span></code></a> <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a> must be identical with the
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorSpaceInterface" title="pymor.vectorarrays.interfaces.VectorSpaceInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorSpace</span></code></a> of the given array. The result will be a vector array from
the <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.range" title="pymor.operators.interfaces.OperatorInterface.range"><code class="xref py py-attr docutils literal notranslate"><span class="pre">range</span></code></a> space. An operator can be <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.linear" title="pymor.operators.interfaces.OperatorInterface.linear"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linear</span></code></a> or not.  The <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.apply_inverse" title="pymor.operators.interfaces.OperatorInterface.apply_inverse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_inverse</span></code></a>
method provides an interface for (linear) solvers.</p>
<p>Operators in pyMOR are also used to represent bilinear forms via the
<a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.apply2" title="pymor.operators.interfaces.OperatorInterface.apply2"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply2</span></code></a> method. A functional in pyMOR is simply an operator with
<code class="docutils literal notranslate"><span class="pre">NumpyVectorSpace(1)</span></code> as <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.range" title="pymor.operators.interfaces.OperatorInterface.range"><code class="xref py py-attr docutils literal notranslate"><span class="pre">range</span></code></a>. Dually, a vector-like operator is an operator
with <code class="docutils literal notranslate"><span class="pre">NumpyVectorSpace(1)</span></code> as <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.source" title="pymor.operators.interfaces.OperatorInterface.source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source</span></code></a>. Such vector-like operators are used
in pyMOR to represent <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> dependent vectors such as the initial data
of an <a class="reference internal" href="generated/pymor.models.html#pymor.models.basic.InstationaryModel" title="pymor.models.basic.InstationaryModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstationaryModel</span></code></a>. For linear functionals and vector-like
operators, the <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.as_vector" title="pymor.operators.interfaces.OperatorInterface.as_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_vector</span></code></a> method can be called to obtain a vector
representation of the operator as a <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a> of length 1.</p>
<p>Linear combinations of operators can be formed using a <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.constructions.LincombOperator" title="pymor.operators.constructions.LincombOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">LincombOperator</span></code></a>.
When such a linear combination is <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface.assemble" title="pymor.operators.interfaces.OperatorInterface.assemble"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assembled</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">_assemble_lincomb</span></code>
is called to ensure that, for instance, linear combinations of operators
represented by a matrix lead to a new operator holding the linear
combination of the matrices.</p>
<p>Default implementations for many methods of the operator interface can be
found in <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.basic.OperatorBase" title="pymor.operators.basic.OperatorBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">OperatorBase</span></code></a>. Base classes for <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.17)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">NumPy</span></code></a>-based operators can be
found in <a class="reference internal" href="generated/pymor.operators.html#module-pymor.operators.numpy" title="pymor.operators.numpy"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymor.operators.numpy</span></code></a>. Several methods for constructing
new operators from existing ones are contained in
<a class="reference internal" href="generated/pymor.operators.html#module-pymor.operators.constructions" title="pymor.operators.constructions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymor.operators.constructions</span></code></a>.</p>
</dd>
<dt><a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a></dt><dd><p>Models in pyMOR encode the mathematical structure of a given
discrete problem by acting as container classes for operators. Each
model object has <code class="xref py py-attr docutils literal notranslate"><span class="pre">operators</span></code>, <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.products" title="pymor.models.interfaces.ModelInterface.products"><code class="xref py py-attr docutils literal notranslate"><span class="pre">products</span></code></a> dictionaries holding the
<a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a> which appear in the formulation of the discrete problem. The
keys in these dictionaries describe the role of the respective operator
in the discrete problem.</p>
<p>Apart from describing the discrete problem, models also implement
algorithms for <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.solve" title="pymor.models.interfaces.ModelInterface.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solving</span></code></a> the given problem, returning <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a>
from the <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.solution_space" title="pymor.models.interfaces.ModelInterface.solution_space"><code class="xref py py-attr docutils literal notranslate"><span class="pre">solution_space</span></code></a>. The solution can be <a class="reference internal" href="generated/pymor.core.html#module-pymor.core.cache" title="pymor.core.cache"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cached</span></code></a>, s.t.
subsequent solving of the problem for the same parameter reduces to
looking up the solution in pyMOR’s cache.</p>
<p>While special model classes may be implemented which make use of
the specific types of operators they contain (e.g. using some external
high-dimensional solver for the problem), it is generally favourable to
implement the solution algorithms only through the interfaces provided by
the operators contained in the model, as this allows to use the
same model class to solve high-dimensional and reduced problems.
This has been done for the simple stationary and instationary
models found in <a class="reference internal" href="generated/pymor.models.html#module-pymor.models.basic" title="pymor.models.basic"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymor.models.basic</span></code></a>.</p>
<p>Models can also implement <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.estimate" title="pymor.models.interfaces.ModelInterface.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate</span></code></a> and <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.visualize" title="pymor.models.interfaces.ModelInterface.visualize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visualize</span></code></a> methods to
estimate the discretization or model reduction error of a computed solution
and create graphic representations of <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a> from the
<a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.solution_space" title="pymor.models.interfaces.ModelInterface.solution_space"><code class="xref py py-attr docutils literal notranslate"><span class="pre">solution_space</span></code></a>.</p>
</dd>
</dl>
</div>
<div class="section" id="base-classes">
<h2>Base Classes<a class="headerlink" href="#base-classes" title="Permalink to this headline">¶</a></h2>
<p>While <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a> are mutable objects, both <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a> and <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a>
are immutable in pyMOR: the application of an <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a> to the same
<a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArray</span></code></a> will always lead to the same result, solving a <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>
for the same parameter will always produce the same solution array. This has two
main benefits:</p>
<ol class="arabic simple">
<li><p>If multiple objects/algorithms hold references to the same
<a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a> or <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, none of the objects has to worry that the
referenced object changes without their knowledge.</p></li>
<li><p>It becomes affordable to generate persistent keys for <a class="reference internal" href="generated/pymor.core.html#module-pymor.core.cache" title="pymor.core.cache"><code class="xref py py-mod docutils literal notranslate"><span class="pre">caching</span></code></a> of computation
results by generating <a class="reference internal" href="generated/pymor.core.html#state-id"><span class="std std-ref">state ids</span></a> which uniquely identify the object’s state.
Since the state cannot change, these ids have to be computed only once for the
lifetime of the object.</p></li>
</ol>
<p>A class can be made immutable in pyMOR by deriving from <a class="reference internal" href="generated/pymor.core.html#pymor.core.interfaces.ImmutableInterface" title="pymor.core.interfaces.ImmutableInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableInterface</span></code></a>,
which ensures that write access to the object’s attributes is prohibited after
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> has been executed. However, note that changes to private attributes
(attributes whose name starts with <code class="docutils literal notranslate"><span class="pre">_</span></code>) are still allowed. It lies in the
implementors responsibility to ensure that changes to these attributes do not
affect the outcome of calls to relevant interface methods. As an example, a call
to <a class="reference internal" href="generated/pymor.core.html#pymor.core.cache.CacheableInterface.enable_caching" title="pymor.core.cache.CacheableInterface.enable_caching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enable_caching</span></code></a> will set the
objects private <code class="docutils literal notranslate"><span class="pre">__cache_region</span></code> attribute, which might affect the speed of a
subsequent <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface.solve" title="pymor.models.interfaces.ModelInterface.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> call, but not its result.</p>
<p>Of course, in many situations one may wish to change properties of an immutable
object, e.g. the number of timesteps for a given model. This can be
easily achieved using the
<a class="reference internal" href="generated/pymor.core.html#pymor.core.interfaces.ImmutableInterface.with_" title="pymor.core.interfaces.ImmutableInterface.with_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_</span></code></a> method every immutable
object has: a call of the form <code class="docutils literal notranslate"><span class="pre">o.with_(a=x,</span> <span class="pre">b=y)</span></code> will return a copy of <code class="docutils literal notranslate"><span class="pre">o</span></code>
in which the attribute <code class="docutils literal notranslate"><span class="pre">a</span></code> now has the value <code class="docutils literal notranslate"><span class="pre">x</span></code> and the attribute <code class="docutils literal notranslate"><span class="pre">b</span></code> the
value <code class="docutils literal notranslate"><span class="pre">y</span></code>. It can be generally assumed that calls to
<a class="reference internal" href="generated/pymor.core.html#pymor.core.interfaces.ImmutableInterface.with_" title="pymor.core.interfaces.ImmutableInterface.with_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_</span></code></a> are inexpensive. The
set of allowed arguments can be found in the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">with_arguments</span></code> attribute.</p>
<p>All immutable classes in pyMOR and most other classes derive from
<a class="reference internal" href="generated/pymor.core.html#pymor.core.interfaces.BasicInterface" title="pymor.core.interfaces.BasicInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasicInterface</span></code></a> which, through its meta class, provides several convenience
features for pyMOR. Most notably, every subclass of <a class="reference internal" href="generated/pymor.core.html#pymor.core.interfaces.BasicInterface" title="pymor.core.interfaces.BasicInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasicInterface</span></code></a> obtains its
own <a class="reference internal" href="generated/pymor.core.html#pymor.core.interfaces.BasicInterface.logger" title="pymor.core.interfaces.BasicInterface.logger"><code class="xref py py-attr docutils literal notranslate"><span class="pre">logger</span></code></a> instance with a class
specific prefix.</p>
</div>
<div class="section" id="creating-models">
<h2>Creating Models<a class="headerlink" href="#creating-models" title="Permalink to this headline">¶</a></h2>
<p>pyMOR ships a small (and still quite incomplete) framework for creating finite
element or finite volume discretizations based on the <a class="reference external" href="http://scipy.org">NumPy/Scipy</a> software stack. To end up with an appropriate
<a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, one starts by instantiating an <a class="reference internal" href="generated/pymor.analyticalproblems.html#module-pymor.analyticalproblems" title="pymor.analyticalproblems"><code class="xref py py-mod docutils literal notranslate"><span class="pre">analytical</span> <span class="pre">problem</span></code></a> which
describes the problem we want to discretize. <a class="reference internal" href="generated/pymor.analyticalproblems.html#module-pymor.analyticalproblems" title="pymor.analyticalproblems"><code class="xref py py-mod docutils literal notranslate"><span class="pre">analytical</span> <span class="pre">problems</span></code></a> contain
<a class="reference internal" href="generated/pymor.functions.html#pymor.functions.interfaces.FunctionInterface" title="pymor.functions.interfaces.FunctionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Functions</span></code></a> which define the analytical data functions associated with the
problem and a <a class="reference internal" href="generated/pymor.domaindescriptions.html#pymor.domaindescriptions.interfaces.DomainDescriptionInterface" title="pymor.domaindescriptions.interfaces.DomainDescriptionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">DomainDescription</span></code></a> that provides a geometrical definition of the
domain the problem is posed on and associates a boundary type to each part of
its boundary.</p>
<p>To obtain a <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> from an <a class="reference internal" href="generated/pymor.analyticalproblems.html#module-pymor.analyticalproblems" title="pymor.analyticalproblems"><code class="xref py py-mod docutils literal notranslate"><span class="pre">analytical</span> <span class="pre">problem</span></code></a> we use a
<a class="reference internal" href="generated/pymor.discretizers.html#module-pymor.discretizers" title="pymor.discretizers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">discretizer</span></code></a>. A discretizer will first mesh the
computational domain by feeding the <a class="reference internal" href="generated/pymor.domaindescriptions.html#pymor.domaindescriptions.interfaces.DomainDescriptionInterface" title="pymor.domaindescriptions.interfaces.DomainDescriptionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">DomainDescription</span></code></a> into a
<a class="reference internal" href="generated/pymor.domaindiscretizers.html#module-pymor.domaindiscretizers" title="pymor.domaindiscretizers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">domaindiscretizer</span></code></a> which will return the <a class="reference internal" href="generated/pymor.grids.html#pymor.grids.interfaces.AffineGridInterface" title="pymor.grids.interfaces.AffineGridInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Grid</span></code></a>
along with a <a class="reference internal" href="generated/pymor.grids.html#pymor.grids.interfaces.BoundaryInfoInterface" title="pymor.grids.interfaces.BoundaryInfoInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundaryInfo</span></code></a> associating boundary entities with boundary types.
Next, the <a class="reference internal" href="generated/pymor.grids.html#pymor.grids.interfaces.AffineGridInterface" title="pymor.grids.interfaces.AffineGridInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Grid</span></code></a>, <a class="reference internal" href="generated/pymor.grids.html#pymor.grids.interfaces.BoundaryInfoInterface" title="pymor.grids.interfaces.BoundaryInfoInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundaryInfo</span></code></a> and the various data functions of the
<a class="reference internal" href="generated/pymor.analyticalproblems.html#module-pymor.analyticalproblems" title="pymor.analyticalproblems"><code class="xref py py-mod docutils literal notranslate"><span class="pre">analytical</span> <span class="pre">problem</span></code></a> are used to instatiate <a class="reference internal" href="generated/pymor.operators.html#module-pymor.operators.cg" title="pymor.operators.cg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">finite</span> <span class="pre">element</span></code></a> or <a class="reference internal" href="generated/pymor.operators.html#module-pymor.operators.fv" title="pymor.operators.fv"><code class="xref py py-mod docutils literal notranslate"><span class="pre">finite</span> <span class="pre">volume</span></code></a> operators.
Finally these operators are used to instatiate one of the provided
<a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> classes.</p>
<p>In pyMOR, <a class="reference internal" href="generated/pymor.analyticalproblems.html#module-pymor.analyticalproblems" title="pymor.analyticalproblems"><code class="xref py py-mod docutils literal notranslate"><span class="pre">analytical</span> <span class="pre">problems</span></code></a>, <a class="reference internal" href="generated/pymor.functions.html#pymor.functions.interfaces.FunctionInterface" title="pymor.functions.interfaces.FunctionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Functions</span></code></a>, <a class="reference internal" href="generated/pymor.domaindescriptions.html#pymor.domaindescriptions.interfaces.DomainDescriptionInterface" title="pymor.domaindescriptions.interfaces.DomainDescriptionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">DomainDescriptions</span></code></a>,
<a class="reference internal" href="generated/pymor.grids.html#pymor.grids.interfaces.BoundaryInfoInterface" title="pymor.grids.interfaces.BoundaryInfoInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundaryInfos</span></code></a> and <a class="reference internal" href="generated/pymor.grids.html#pymor.grids.interfaces.AffineGridInterface" title="pymor.grids.interfaces.AffineGridInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Grids</span></code></a> are all immutable, enabling efficient
disk <a class="reference internal" href="generated/pymor.core.html#module-pymor.core.cache" title="pymor.core.cache"><code class="xref py py-mod docutils literal notranslate"><span class="pre">caching</span></code></a> for the resulting <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a>, persistent over various
runs of the applications written with pyMOR.</p>
<p>While pyMOR’s internal discretizations are useful for getting started quickly
with model reduction experiments, pyMOR’s main goal is to allow the reduction of
models provided by external solvers. In order to do so, all that needs
to be done is to provide <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a>, <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a> and <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a> which
interact appropriately with the solver. pyMOR makes no assumption on how the
communication with the solver is managed. For instance, communication could take
place via a network protocol or job files.  In particular it should be stressed
that in general no communication of high-dimensional data between the solver
and pyMOR is necessary: <a class="reference internal" href="generated/pymor.vectorarrays.html#pymor.vectorarrays.interfaces.VectorArrayInterface" title="pymor.vectorarrays.interfaces.VectorArrayInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">VectorArrays</span></code></a> can merely hold handles to data in the
solver’s memory or some on-disk database. Where possible, we favour, however, a
deep integration of the solver with pyMOR by linking the solver code as a Python
extension module. This allows Python to directly access the solver’s data
structures which can be used to quickly add features to the high-dimensional
code without any recompilation. A minimal example for such an integration using
<a class="reference external" href="https://code.google.com/p/pybindgen">pybindgen</a> can be found in the
<code class="docutils literal notranslate"><span class="pre">src/pymordemos/minimal_cpp_demo</span></code> directory of the pyMOR repository.
Bindings for <a class="reference external" href="https://fenicsproject.org">FEnicS</a> and
<a class="reference external" href="https://ngsolve.org">NGSolve</a> packages are available in the
<a class="reference internal" href="generated/pymor.bindings.html#module-pymor.bindings.fenics" title="pymor.bindings.fenics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bindings.fenics</span></code></a> and
<a class="reference internal" href="generated/pymor.bindings.html#module-pymor.bindings.ngsolve" title="pymor.bindings.ngsolve"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bindings.ngsolve</span></code></a> modules.
The <a class="reference external" href="https://github.com/pymor/pymor-deal.II">pymor-deal.II</a> repository contains
experimental bindings for <a class="reference external" href="https://dealii.org">deal.II</a>.</p>
</div>
<div class="section" id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>pyMOR classes implement dependence on a parameter by deriving from the
<a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric" title="pymor.parameters.base.Parametric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parametric</span></code></a> mix-in class. This class gives each instance a
<a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric.parameter_type" title="pymor.parameters.base.Parametric.parameter_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parameter_type</span></code></a> attribute describing the
form of <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code></a> the relevant methods of the object (<code class="docutils literal notranslate"><span class="pre">apply</span></code>, <code class="docutils literal notranslate"><span class="pre">solve</span></code>,
<code class="docutils literal notranslate"><span class="pre">evaluate</span></code>, etc.) expect. A <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> in pyMOR is basically a Python
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> with strings as keys and <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NumPy</span> <span class="pre">arrays</span></code></a> as values. Each such value
is called a <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> component. The <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.ParameterType" title="pymor.parameters.base.ParameterType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterType</span></code></a> of a <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> is
simply obtained by replacing the arrays in the <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> with their shape.
I.e. a <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.ParameterType" title="pymor.parameters.base.ParameterType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterType</span></code></a> specifies the names of the parameter components and their
expected shapes.</p>
<p>The <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.ParameterType" title="pymor.parameters.base.ParameterType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterType</span></code></a> of a <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric" title="pymor.parameters.base.Parametric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parametric</span></code></a> object is determined by the class
implementor during <code class="docutils literal notranslate"><span class="pre">__init__</span></code> via a call to
<a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric.build_parameter_type" title="pymor.parameters.base.Parametric.build_parameter_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">build_parameter_type</span></code></a>, which can be
used to infer the <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.ParameterType" title="pymor.parameters.base.ParameterType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterType</span></code></a> from the <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.ParameterType" title="pymor.parameters.base.ParameterType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterTypes</span></code></a> of objects the
given object depends upon. I.e. an <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a> implementing the L2-product with
some <a class="reference internal" href="generated/pymor.functions.html#pymor.functions.interfaces.FunctionInterface" title="pymor.functions.interfaces.FunctionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> will inherit the <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.ParameterType" title="pymor.parameters.base.ParameterType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterType</span></code></a> of the <a class="reference internal" href="generated/pymor.functions.html#pymor.functions.interfaces.FunctionInterface" title="pymor.functions.interfaces.FunctionInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a>.</p>
<p>Reading the <a class="reference internal" href="generated/pymor.parameters.html#module-pymor.parameters.base" title="pymor.parameters.base"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reference</span> <span class="pre">documentation</span></code></a> on pyMOR’s
parameter handling facilities is strongly advised for implementors of
<a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric" title="pymor.parameters.base.Parametric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parametric</span></code></a> classes.</p>
</div>
<div class="section" id="defaults">
<h2>Defaults<a class="headerlink" href="#defaults" title="Permalink to this headline">¶</a></h2>
<p>pyMOR offers a convenient mechanism for handling default values such as solver
tolerances, cache sizes, log levels, etc. Each default in pyMOR is the default
value of an optional argument of some function. Such an argument is made a
default by decorating the function with the <a class="reference internal" href="generated/pymor.core.html#pymor.core.defaults.defaults" title="pymor.core.defaults.defaults"><code class="xref py py-func docutils literal notranslate"><span class="pre">defaults</span></code></a>
decorator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@defaults</span><span class="p">(</span><span class="s1">&#39;tolerance&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">some_algorithm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Default values can be changed by calling <a class="reference internal" href="generated/pymor.core.html#pymor.core.defaults.set_defaults" title="pymor.core.defaults.set_defaults"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_defaults</span></code></a>.
By calling <a class="reference internal" href="generated/pymor.core.html#pymor.core.defaults.print_defaults" title="pymor.core.defaults.print_defaults"><code class="xref py py-func docutils literal notranslate"><span class="pre">print_defaults</span></code></a> a summary of all defaults
in pyMOR and their values can be printed. A configuration file with all defaults
can be obtained with <a class="reference internal" href="generated/pymor.core.html#pymor.core.defaults.write_defaults_to_file" title="pymor.core.defaults.write_defaults_to_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">write_defaults_to_file</span></code></a>. This file can
then be loaded, either programmatically or automatically by setting the
<code class="docutils literal notranslate"><span class="pre">PYMOR_DEFAULTS</span></code> environment variable.</p>
<p>As an additional feature, if <code class="docutils literal notranslate"><span class="pre">None</span></code> is passed as value for a function argument
which is a default, its default value is used instead of <code class="docutils literal notranslate"><span class="pre">None</span></code>. This allows
writing code of the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">method_called_by_user</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">tolerance_for_algorithm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">algorithm</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance_for_algorithm</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="generated/pymor.core.html#module-pymor.core.defaults" title="pymor.core.defaults"><code class="xref py py-mod docutils literal notranslate"><span class="pre">defaults</span></code></a> module for more information.</p>
</div>
<div class="section" id="ruletables">
<h2>RuleTables<a class="headerlink" href="#ruletables" title="Permalink to this headline">¶</a></h2>
<p>Many algorithms in pyMOR can be seen as transformations acting on trees of
<a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a>. One example is the structure-preserving (Petrov-)Galerkin
projection of <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a> performed by the <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.projection.project" title="pymor.algorithms.projection.project"><code class="xref py py-func docutils literal notranslate"><span class="pre">project</span></code></a> method. For instance, a
<a class="reference internal" href="generated/pymor.operators.html#pymor.operators.constructions.LincombOperator" title="pymor.operators.constructions.LincombOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">LincombOperator</span></code></a> is projected by replacing all its children (the <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a>
forming the affine decomposition) with projected <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a>.</p>
<p>During development of pyMOR, it turned out that using inheritance for selecting
the action to be taken to project a specific operator (i.e. single dispatch
based on the class of the to-be-projected <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a>) is not sufficiently
flexible. With pyMOR 0.5 we have introduced algorithms which are based on
<a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable" title="pymor.algorithms.rules.RuleTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleTables</span></code></a> instead of inheritance. A <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable" title="pymor.algorithms.rules.RuleTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleTable</span></code></a> is simply an ordered list of
<a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.rule" title="pymor.algorithms.rules.rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">rules</span></code></a>, i.e. pairs of conditions to match
with corresponding actions. When a <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable" title="pymor.algorithms.rules.RuleTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleTable</span></code></a> is <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable.apply" title="pymor.algorithms.rules.RuleTable.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">applied</span></code></a> to an object (e.g. an <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a>),
the action associated with the first matching rule in the table is executed. As
part of the action, the <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable" title="pymor.algorithms.rules.RuleTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleTable</span></code></a> can be easily <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable.apply_children" title="pymor.algorithms.rules.RuleTable.apply_children"><code class="xref py py-meth docutils literal notranslate"><span class="pre">applied</span> <span class="pre">recursively</span></code></a> to the children of the given
object.</p>
<p>This approach has several advantages over an inheritance-based model:</p>
<ul class="simple">
<li><p>Rules can match based on the class of the object, but also on more general
conditions, i.e. the name of the <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a> or being linear and non-<a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric.parametric" title="pymor.parameters.base.Parametric.parametric"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parametric</span></code></a>.</p></li>
<li><p>The entire mathematical algorithm can be specified in a single file even when the
definition of the possible classes the algorithm can be applied to is scattered
over various files.</p></li>
<li><p>The precedence of rules is directly apparent from the definition of the <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable" title="pymor.algorithms.rules.RuleTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleTable</span></code></a>.</p></li>
<li><p>Generic rules (e.g. the projection of a linear non-<a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parametric.parametric" title="pymor.parameters.base.Parametric.parametric"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parametric</span></code></a> <a class="reference internal" href="generated/pymor.operators.html#pymor.operators.interfaces.OperatorInterface" title="pymor.operators.interfaces.OperatorInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a> by simply
applying the basis) can be easily scheduled to take precedence over more specific
rules.</p></li>
<li><p>Users can implement or modify <a class="reference internal" href="generated/pymor.algorithms.html#pymor.algorithms.rules.RuleTable" title="pymor.algorithms.rules.RuleTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleTables</span></code></a> without modification of the classes
shipped with pyMOR.</p></li>
</ul>
</div>
<div class="section" id="the-reduction-process">
<h2>The Reduction Process<a class="headerlink" href="#the-reduction-process" title="Permalink to this headline">¶</a></h2>
<p>The reduction process in pyMOR is handled by so called <a class="reference internal" href="generated/pymor.reductors.html#module-pymor.reductors" title="pymor.reductors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reductors</span></code></a>
which take arbitrary <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a> and additional data (e.g. the reduced
basis) to create reduced <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a>. If proper offline/online
decomposition is achieved by the reductor, the reduced <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> will
not store any high-dimensional data. Note that there is no inherent distinction
between low- and high-dimensional <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Models</span></code></a> in pyMOR. The only
difference lies in the different types of operators, the <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>
contains.</p>
<p>This observation is particularly apparent in the case of the classical
reduced basis method: the operators and functionals of a given discrete problem
are projected onto the reduced basis space whereas the structure of the problem
(i.e. the type of <a class="reference internal" href="generated/pymor.models.html#pymor.models.interfaces.ModelInterface" title="pymor.models.interfaces.ModelInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> containing the operators) stays the same.
pyMOR reflects this fact by offering with <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericRBReductor</span></code>
a generic algorithm which can be used to RB-project any model available to pyMOR.
It should be noted however that this reductor is only able to efficiently
offline/online-decompose affinely <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a>-dependent linear problems.
Non-linear problems or such with no affine <a class="reference internal" href="generated/pymor.parameters.html#pymor.parameters.base.Parameter" title="pymor.parameters.base.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> dependence require
additional techniques such as <a class="reference internal" href="generated/pymor.algorithms.html#module-pymor.algorithms.ei" title="pymor.algorithms.ei"><code class="xref py py-mod docutils literal notranslate"><span class="pre">empirical</span> <span class="pre">interpolation</span></code></a>.</p>
<p>If you want to further dive into the inner workings of pyMOR, we highly
recommend to study the source code of <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericRBReductor</span></code>
and to step through calls of this method with a Python debugger, such as
<a class="reference external" href="https://pypi.python.org/pypi/ipdb">ipdb</a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Technical Overview</a><ul>
<li><a class="reference internal" href="#three-central-classes">Three Central Classes</a></li>
<li><a class="reference internal" href="#base-classes">Base Classes</a></li>
<li><a class="reference internal" href="#creating-models">Creating Models</a></li>
<li><a class="reference internal" href="#parameters">Parameters</a></li>
<li><a class="reference internal" href="#defaults">Defaults</a></li>
<li><a class="reference internal" href="#ruletables">RuleTables</a></li>
<li><a class="reference internal" href="#the-reduction-process">The Reduction Process</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="getting_started.html"
                        title="previous chapter">Getting started</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="environment.html"
                        title="next chapter">Environment Variables</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/technical_overview.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="environment.html" title="Environment Variables"
             >next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="Getting started"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyMOR v2019.2rc0+680.g9bf3f73a.dirty Manual</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2019 pyMOR developers and contributors.
      Last updated on Dec 05, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>