
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pymor.algorithms.genericsolvers &#8212; pyMOR v2019.2rc0+680.g9bf3f73a.dirty Manual</title>
    <link rel="stylesheet" href="../../../_static/pymor.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pyMOR v2019.2rc0+680.g9bf3f73a.dirty Manual</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymor.algorithms.genericsolvers</h1><div class="highlight"><pre>
<span></span><span class="c1"># This file is part of the pyMOR project (http://www.pymor.org).</span>
<span class="c1"># Copyright 2013-2019 pyMOR developers and contributors. All rights reserved.</span>
<span class="c1"># License: BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)</span>

<span class="sd">&quot;&quot;&quot;This module contains some iterative linear solvers which only use the |Operator| interface&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymor.core.defaults</span> <span class="k">import</span> <span class="n">defaults</span>
<span class="kn">from</span> <span class="nn">pymor.core.exceptions</span> <span class="k">import</span> <span class="n">InversionError</span>
<span class="kn">from</span> <span class="nn">pymor.core.logger</span> <span class="k">import</span> <span class="n">getLogger</span>


<div class="viewcode-block" id="solver_options"><a class="viewcode-back" href="../../../generated/pymor.algorithms.html#pymor.algorithms.genericsolvers.solver_options">[docs]</a><span class="nd">@defaults</span><span class="p">(</span><span class="s1">&#39;lgmres_tol&#39;</span><span class="p">,</span> <span class="s1">&#39;lgmres_maxiter&#39;</span><span class="p">,</span>
          <span class="s1">&#39;lgmres_inner_m&#39;</span><span class="p">,</span> <span class="s1">&#39;lgmres_outer_k&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsmr_damp&#39;</span><span class="p">,</span>
          <span class="s1">&#39;least_squares_lsmr_atol&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsmr_btol&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsmr_conlim&#39;</span><span class="p">,</span>
          <span class="s1">&#39;least_squares_lsmr_maxiter&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsmr_show&#39;</span><span class="p">,</span>
          <span class="s1">&#39;least_squares_lsqr_atol&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsqr_btol&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsqr_conlim&#39;</span><span class="p">,</span>
          <span class="s1">&#39;least_squares_lsqr_iter_lim&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsqr_show&#39;</span><span class="p">,</span>
          <span class="n">sid_ignore</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;least_squares_lsmr_show&#39;</span><span class="p">,</span> <span class="s1">&#39;least_squares_lsqr_show&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">solver_options</span><span class="p">(</span><span class="n">lgmres_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                   <span class="n">lgmres_maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                   <span class="n">lgmres_inner_m</span><span class="o">=</span><span class="mi">39</span><span class="p">,</span>
                   <span class="n">lgmres_outer_k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                   <span class="n">least_squares_lsmr_damp</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">least_squares_lsmr_atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                   <span class="n">least_squares_lsmr_btol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                   <span class="n">least_squares_lsmr_conlim</span><span class="o">=</span><span class="mf">1e8</span><span class="p">,</span>
                   <span class="n">least_squares_lsmr_maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">least_squares_lsmr_show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">least_squares_lsqr_damp</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">least_squares_lsqr_atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                   <span class="n">least_squares_lsqr_btol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                   <span class="n">least_squares_lsqr_conlim</span><span class="o">=</span><span class="mf">1e8</span><span class="p">,</span>
                   <span class="n">least_squares_lsqr_iter_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">least_squares_lsqr_show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns available solvers with default |solver_options|.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lgmres_tol</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lgmres`.</span>
<span class="sd">    lgmres_maxiter</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lgmres`.</span>
<span class="sd">    lgmres_inner_m</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lgmres`.</span>
<span class="sd">    lgmres_outer_k</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lgmres`.</span>
<span class="sd">    least_squares_lsmr_damp</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsmr`.</span>
<span class="sd">    least_squares_lsmr_atol</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsmr`.</span>
<span class="sd">    least_squares_lsmr_btol</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsmr`.</span>
<span class="sd">    least_squares_lsmr_conlim</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsmr`.</span>
<span class="sd">    least_squares_lsmr_maxiter</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsmr`.</span>
<span class="sd">    least_squares_lsmr_show</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsmr`.</span>
<span class="sd">    least_squares_lsqr_damp</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsqr`.</span>
<span class="sd">    least_squares_lsqr_atol</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsqr`.</span>
<span class="sd">    least_squares_lsqr_btol</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsqr`.</span>
<span class="sd">    least_squares_lsqr_conlim</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsqr`.</span>
<span class="sd">    least_squares_lsqr_iter_lim</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsqr`.</span>
<span class="sd">    least_squares_lsqr_show</span>
<span class="sd">        See :func:`scipy.sparse.linalg.lsqr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A dict of available solvers with default |solver_options|.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;generic_lgmres&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;generic_lgmres&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;tol&#39;</span><span class="p">:</span> <span class="n">lgmres_tol</span><span class="p">,</span>
                               <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">lgmres_maxiter</span><span class="p">,</span>
                               <span class="s1">&#39;inner_m&#39;</span><span class="p">:</span> <span class="n">lgmres_inner_m</span><span class="p">,</span>
                               <span class="s1">&#39;outer_k&#39;</span><span class="p">:</span> <span class="n">lgmres_outer_k</span><span class="p">},</span>
            <span class="s1">&#39;generic_least_squares_lsmr&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;generic_least_squares_lsmr&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;damp&#39;</span><span class="p">:</span> <span class="n">least_squares_lsmr_damp</span><span class="p">,</span>
                                           <span class="s1">&#39;atol&#39;</span><span class="p">:</span> <span class="n">least_squares_lsmr_atol</span><span class="p">,</span>
                                           <span class="s1">&#39;btol&#39;</span><span class="p">:</span> <span class="n">least_squares_lsmr_btol</span><span class="p">,</span>
                                           <span class="s1">&#39;conlim&#39;</span><span class="p">:</span> <span class="n">least_squares_lsmr_conlim</span><span class="p">,</span>
                                           <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">least_squares_lsmr_maxiter</span><span class="p">,</span>
                                           <span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="n">least_squares_lsmr_show</span><span class="p">},</span>
            <span class="s1">&#39;generic_least_squares_lsqr&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;generic_least_squares_lsqr&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;damp&#39;</span><span class="p">:</span> <span class="n">least_squares_lsqr_damp</span><span class="p">,</span>
                                           <span class="s1">&#39;atol&#39;</span><span class="p">:</span> <span class="n">least_squares_lsqr_atol</span><span class="p">,</span>
                                           <span class="s1">&#39;btol&#39;</span><span class="p">:</span> <span class="n">least_squares_lsqr_btol</span><span class="p">,</span>
                                           <span class="s1">&#39;conlim&#39;</span><span class="p">:</span> <span class="n">least_squares_lsqr_conlim</span><span class="p">,</span>
                                           <span class="s1">&#39;iter_lim&#39;</span><span class="p">:</span> <span class="n">least_squares_lsqr_iter_lim</span><span class="p">,</span>
                                           <span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="n">least_squares_lsqr_show</span><span class="p">}}</span></div>


<div class="viewcode-block" id="apply_inverse"><a class="viewcode-back" href="../../../generated/pymor.algorithms.html#pymor.algorithms.genericsolvers.apply_inverse">[docs]</a><span class="nd">@defaults</span><span class="p">(</span><span class="s1">&#39;check_finite&#39;</span><span class="p">,</span> <span class="s1">&#39;default_solver&#39;</span><span class="p">,</span> <span class="s1">&#39;default_least_squares_solver&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_inverse</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">least_squares</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">default_solver</span><span class="o">=</span><span class="s1">&#39;generic_lgmres&#39;</span><span class="p">,</span> <span class="n">default_least_squares_solver</span><span class="o">=</span><span class="s1">&#39;generic_least_squares_lsmr&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve linear equation system.</span>

<span class="sd">    Applies the inverse of `op` to the vectors in `rhs` using a generic iterative solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op</span>
<span class="sd">        The linear, non-parametric |Operator| to invert.</span>
<span class="sd">    rhs</span>
<span class="sd">        |VectorArray| of right-hand sides for the equation system.</span>
<span class="sd">    options</span>
<span class="sd">        The |solver_options| to use (see :func:`solver_options`).</span>
<span class="sd">    least_squares</span>
<span class="sd">        If `True`, return least squares solution.</span>
<span class="sd">    check_finite</span>
<span class="sd">        Test if solution only contains finite values.</span>
<span class="sd">    default_solver</span>
<span class="sd">        Default solver to use (generic_lgmres, generic_least_squares_lsmr, generic_least_squares_lsqr).</span>
<span class="sd">    default_least_squares_solver</span>
<span class="sd">        Default solver to use for least squares problems (generic_least_squares_lsmr,</span>
<span class="sd">        generic_least_squares_lsqr).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    |VectorArray| of the solution vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">options</span> <span class="o">=</span> <span class="n">_parse_options</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">solver_options</span><span class="p">(),</span> <span class="n">default_solver</span><span class="p">,</span> <span class="n">default_least_squares_solver</span><span class="p">,</span> <span class="n">least_squares</span><span class="p">)</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">reserve</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;generic_lgmres&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)):</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">lgmres</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                             <span class="n">tol</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">],</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxiter&#39;</span><span class="p">],</span>
                             <span class="n">inner_m</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;inner_m&#39;</span><span class="p">],</span>
                             <span class="n">outer_k</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;outer_k&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InversionError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;lgmres failed to converge after </span><span class="si">{info}</span><span class="s1"> iterations&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;generic_least_squares_lsmr&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)):</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lsmr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                               <span class="n">damp</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;damp&#39;</span><span class="p">],</span>
                                               <span class="n">atol</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;atol&#39;</span><span class="p">],</span>
                                               <span class="n">btol</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;btol&#39;</span><span class="p">],</span>
                                               <span class="n">conlim</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;conlim&#39;</span><span class="p">],</span>
                                               <span class="n">maxiter</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxiter&#39;</span><span class="p">],</span>
                                               <span class="n">show</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">info</span> <span class="o">&lt;=</span> <span class="mi">7</span>
            <span class="k">if</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InversionError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;lsmr failed to converge after </span><span class="si">{itn}</span><span class="s1"> iterations&#39;</span><span class="p">)</span>
            <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pymor.algorithms.genericsolvers.lsmr&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Converged after </span><span class="si">{itn}</span><span class="s1"> iterations&#39;</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;generic_least_squares_lsqr&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)):</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lsqr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                  <span class="n">damp</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;damp&#39;</span><span class="p">],</span>
                                                  <span class="n">atol</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;atol&#39;</span><span class="p">],</span>
                                                  <span class="n">btol</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;btol&#39;</span><span class="p">],</span>
                                                  <span class="n">conlim</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;conlim&#39;</span><span class="p">],</span>
                                                  <span class="n">iter_lim</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;iter_lim&#39;</span><span class="p">],</span>
                                                  <span class="n">show</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">info</span> <span class="o">&lt;=</span> <span class="mi">7</span>
            <span class="k">if</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InversionError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;lsmr failed to converge after </span><span class="si">{itn}</span><span class="s1"> iterations&#39;</span><span class="p">)</span>
            <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pymor.algorithms.genericsolvers.lsqr&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Converged after </span><span class="si">{itn}</span><span class="s1"> iterations&#39;</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown solver type&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_finite</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="n">InversionError</span><span class="p">(</span><span class="s1">&#39;Result contains non-finite values&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span></div>


<span class="k">def</span> <span class="nf">_parse_options</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">default_options</span><span class="p">,</span> <span class="n">default_solver</span><span class="p">,</span> <span class="n">default_least_squares_solver</span><span class="p">,</span> <span class="n">least_squares</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">default_options</span><span class="p">[</span><span class="n">default_least_squares_solver</span><span class="p">]</span> <span class="k">if</span> <span class="n">least_squares</span> <span class="k">else</span> <span class="n">default_options</span><span class="p">[</span><span class="n">default_solver</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">default_options</span><span class="p">[</span><span class="n">options</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="s1">&#39;type&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="ow">and</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">default_options</span> \
            <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">default_options</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">user_options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">default_options</span><span class="p">[</span><span class="n">user_options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]]</span>
        <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">user_options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">least_squares</span> <span class="o">!=</span> <span class="p">(</span><span class="s1">&#39;least_squares&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]):</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">least_squares</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Non-least squares solver selected for least squares problem.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Least squares solver selected for non-least squares problem.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">options</span>


<span class="c1"># The following code is an adapted version of</span>
<span class="c1"># scipy.sparse.linalg.lgmres.</span>
<span class="c1"># Original copyright notice:</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2009, Pauli Virtanen &lt;pav@iki.fi&gt;</span>
<span class="c1"># Distributed under the same license as Scipy.</span>


<div class="viewcode-block" id="lgmres"><a class="viewcode-back" href="../../../generated/pymor.algorithms.html#pymor.algorithms.genericsolvers.lgmres">[docs]</a><span class="k">def</span> <span class="nf">lgmres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">inner_m</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">outer_k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">outer_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store_outer_Av</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InversionError</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg.basic</span> <span class="k">import</span> <span class="n">lstsq</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># psolve = M.matvec</span>

    <span class="k">if</span> <span class="n">outer_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outer_v</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">b_norm</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">b_norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b_norm</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">k_outer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
        <span class="n">r_outer</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>

        <span class="c1"># -- callback</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># -- check stopping condition</span>
        <span class="n">r_norm</span> <span class="o">=</span> <span class="n">r_outer</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">r_norm</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">b_norm</span> <span class="ow">or</span> <span class="n">r_norm</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># -- inner LGMRES iteration</span>
        <span class="n">vs0</span> <span class="o">=</span> <span class="o">-</span><span class="n">r_outer</span>   <span class="c1"># -psolve(r_outer)</span>
        <span class="n">inner_res_0</span> <span class="o">=</span> <span class="n">vs0</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inner_res_0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rnorm</span> <span class="o">=</span> <span class="n">r_outer</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Preconditioner returned a zero vector; &quot;</span>
                               <span class="s2">&quot;|v| ~ </span><span class="si">%.1g</span><span class="s2">, |M v| = 0&quot;</span> <span class="o">%</span> <span class="n">rnorm</span><span class="p">)</span>

        <span class="n">vs0</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">inner_res_0</span><span class="p">)</span>
        <span class="n">hs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">vs0</span><span class="p">]</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">inner_m</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">outer_v</span><span class="p">)):</span>
            <span class="c1"># -- Arnoldi process:</span>
            <span class="c1">#</span>
            <span class="c1">#    Build an orthonormal basis V and matrices W and H such that</span>
            <span class="c1">#        A W = V H</span>
            <span class="c1">#    Columns of W, V, and H are stored in `ws`, `vs` and `hs`.</span>
            <span class="c1">#</span>
            <span class="c1">#    The first column of V is always the residual vector, `vs0`;</span>
            <span class="c1">#    V has *one more column* than the other of the three matrices.</span>
            <span class="c1">#</span>
            <span class="c1">#    The other columns in V are built by feeding in, one</span>
            <span class="c1">#    by one, some vectors `z` and orthonormalizing them</span>
            <span class="c1">#    against the basis so far. The trick here is to</span>
            <span class="c1">#    feed in first some augmentation vectors, before</span>
            <span class="c1">#    starting to construct the Krylov basis on `v0`.</span>
            <span class="c1">#</span>
            <span class="c1">#    It was shown in [BJM]_ that a good choice (the LGMRES choice)</span>
            <span class="c1">#    for these augmentation vectors are the `dx` vectors obtained</span>
            <span class="c1">#    from a couple of the previous restart cycles.</span>
            <span class="c1">#</span>
            <span class="c1">#    Note especially that while `vs0` is always the first</span>
            <span class="c1">#    column in V, there is no reason why it should also be</span>
            <span class="c1">#    the first column in W. (In fact, below `vs0` comes in</span>
            <span class="c1">#    W only after the augmentation vectors.)</span>
            <span class="c1">#</span>
            <span class="c1">#    The rest of the algorithm then goes as in GMRES, one</span>
            <span class="c1">#    solves a minimization problem in the smaller subspace</span>
            <span class="c1">#    spanned by W (range) and V (image).</span>
            <span class="c1">#</span>
            <span class="c1">#    XXX: Below, I&#39;m lazy and use `lstsq` to solve the</span>
            <span class="c1">#    small least squares problem. Performance-wise, this</span>
            <span class="c1">#    is in practice acceptable, but it could be nice to do</span>
            <span class="c1">#    it on the fly with Givens etc.</span>
            <span class="c1">#</span>

            <span class="c1">#     ++ evaluate</span>
            <span class="n">v_new</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">outer_v</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">z</span><span class="p">,</span> <span class="n">v_new</span> <span class="o">=</span> <span class="n">outer_v</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outer_v</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">vs0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">v_new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v_new</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># psolve(matvec(z))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Note: v_new is modified in-place below. Must make a</span>
                <span class="c1"># copy to ensure that the outer_v vectors are not</span>
                <span class="c1"># clobbered.</span>
                <span class="n">v_new</span> <span class="o">=</span> <span class="n">v_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1">#     ++ orthogonalize</span>
            <span class="n">hcur</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_new</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">hcur</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
                <span class="n">v_new</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>  <span class="c1"># v_new -= alpha*v</span>
            <span class="n">hcur</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_new</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">hcur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Exact solution found; bail out.</span>
                <span class="c1"># Zero basis vector (v_new) in the least-squares problem</span>
                <span class="c1"># does no harm, so we can just use the same code as usually;</span>
                <span class="c1"># it will give zero (inner) residual as a result.</span>
                <span class="n">bailout</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bailout</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">v_new</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">hcur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_new</span><span class="p">)</span>
            <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hcur</span><span class="p">)</span>
            <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="c1"># XXX: Ugly: should implement the GMRES iteration properly,</span>
            <span class="c1">#      with Givens rotations and not using lstsq. Instead, we</span>
            <span class="c1">#      spare some work by solving the LSQ problem only every 5</span>
            <span class="c1">#      iterations.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bailout</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">inner_m</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">outer_v</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># -- GMRES optimization problem</span>
            <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inner_res_0</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="n">hsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hs</span><span class="p">[</span><span class="n">q</span><span class="p">])</span>
                <span class="n">common_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">hess</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">hsq</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">hess</span> <span class="o">=</span> <span class="n">hess</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">common_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">hess</span><span class="p">[:(</span><span class="n">q</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsq</span>

            <span class="n">y</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
            <span class="n">inner_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span>

            <span class="c1"># -- check for termination</span>
            <span class="k">if</span> <span class="n">inner_res</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">inner_res_0</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># -- GMRES terminated: eval solution</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">yc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">dx</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="n">yc</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>  <span class="c1"># dx += w*yc</span>

        <span class="c1"># -- Store LGMRES augmentation vectors</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">dx</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">store_outer_Av</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">qc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">outer_v</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">nx</span><span class="p">),</span> <span class="n">ax</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">nx</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outer_v</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">nx</span><span class="p">),</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># -- Retain only a finite number of augmentation vectors</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">outer_v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">outer_k</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">outer_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># -- Apply step</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">dx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># didn&#39;t converge ...</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">maxiter</span>

    <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pymor.algorithms.genericsolvers.lgmres&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Converged after {k_outer+1} iterations&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span></div>


<span class="c1"># The following code is an adapted version of</span>
<span class="c1"># scipy.sparse.linalg.lsqr.</span>
<span class="c1"># Original copyright notice:</span>
<span class="c1">#</span>
<span class="c1"># Sparse Equations and Least Squares.</span>
<span class="c1">#</span>
<span class="c1"># The original Fortran code was written by C. C. Paige and M. A. Saunders as</span>
<span class="c1"># described in</span>
<span class="c1">#</span>
<span class="c1"># C. C. Paige and M. A. Saunders, LSQR: An algorithm for sparse linear</span>
<span class="c1"># equations and sparse least squares, TOMS 8(1), 43--71 (1982).</span>
<span class="c1">#</span>
<span class="c1"># C. C. Paige and M. A. Saunders, Algorithm 583; LSQR: Sparse linear</span>
<span class="c1"># equations and least-squares problems, TOMS 8(2), 195--209 (1982).</span>
<span class="c1">#</span>
<span class="c1"># It is licensed under the following BSD license:</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2006, Systems Optimization Laboratory</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are</span>
<span class="c1"># met:</span>
<span class="c1">#</span>
<span class="c1">#     * Redistributions of source code must retain the above copyright</span>
<span class="c1">#       notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#     * Redistributions in binary form must reproduce the above</span>
<span class="c1">#       copyright notice, this list of conditions and the following</span>
<span class="c1">#       disclaimer in the documentation and/or other materials provided</span>
<span class="c1">#       with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#     * Neither the name of Stanford University nor the names of its</span>
<span class="c1">#       contributors may be used to endorse or promote products derived</span>
<span class="c1">#       from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="c1"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="c1"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="c1"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="c1"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="c1"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c1"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="c1"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># The Fortran code was translated to Python for use in CVXOPT by Jeffery</span>
<span class="c1"># Kline with contributions by Mridul Aanjaneya and Bob Myhill.</span>
<span class="c1">#</span>
<span class="c1"># Adapted for SciPy by Stefan van der Walt.</span>


<span class="k">def</span> <span class="nf">_sym_ortho</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">tau</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">tau</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">tau</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span>


<div class="viewcode-block" id="lsqr"><a class="viewcode-back" href="../../../generated/pymor.algorithms.html#pymor.algorithms.genericsolvers.lsqr">[docs]</a><span class="k">def</span> <span class="nf">lsqr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">damp</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">btol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">conlim</span><span class="o">=</span><span class="mf">1e8</span><span class="p">,</span>
         <span class="n">iter_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">dim</span>
    <span class="k">if</span> <span class="n">iter_lim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">iter_lim</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The exact solution is  x = 0                              &#39;</span><span class="p">,</span>
           <span class="s1">&#39;Ax - b is small enough, given atol, btol                  &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The least-squares solution is good enough, given atol     &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The estimate of cond(Abar) has exceeded conlim            &#39;</span><span class="p">,</span>
           <span class="s1">&#39;Ax - b is small enough for this machine                   &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The least-squares solution is good enough for this machine&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Cond(Abar) seems to be too large for this machine         &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The iteration limit has been reached                      &#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LSQR            Least-squares solution of  Ax = b&#39;</span><span class="p">)</span>
        <span class="n">str1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;The matrix A has </span><span class="si">{m:8g}</span><span class="s1"> rows  and </span><span class="si">{n:8g}</span><span class="s1"> cols&#39;</span>
        <span class="n">str2</span> <span class="o">=</span> <span class="s1">&#39;damp = </span><span class="si">%20.14e</span><span class="s1">  &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">damp</span><span class="p">)</span>
        <span class="n">str3</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;atol = </span><span class="si">{atol:8.2e}</span><span class="s1">                 conlim = </span><span class="si">{conlim:8.2e}</span><span class="s1">&#39;</span>
        <span class="n">str4</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;btol = </span><span class="si">{btol:8.2e}</span><span class="s1">               iter_lim = </span><span class="si">{iter_lim:8g}</span><span class="s1">&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str4</span><span class="p">)</span>

    <span class="n">itn</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">istop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># nstop = 0</span>
    <span class="n">ctol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">conlim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ctol</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">conlim</span>
    <span class="n">anorm</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">acond</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dampsq</span> <span class="o">=</span> <span class="n">damp</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">ddnorm</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xnorm</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xxnorm</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cs2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">sn2</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set up the first vectors u and v for the bidiagonalization.</span>
<span class="sd">    These satisfy  beta*u = b,  alfa*v = A&#39;u.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># __xm = A.range.zeros()  # a matrix for temporary holding</span>
    <span class="c1"># __xn = A.source.zeros()  # a matrix for temporary holding</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
    <span class="n">alfa</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">u</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply_adjoint</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">alfa</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">alfa</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">v</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">alfa</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">rhobar</span> <span class="o">=</span> <span class="n">alfa</span>
    <span class="n">phibar</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="n">bnorm</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="n">rnorm</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="n">r1norm</span> <span class="o">=</span> <span class="n">rnorm</span>
    <span class="n">r2norm</span> <span class="o">=</span> <span class="n">rnorm</span>

    <span class="c1"># Reverse the order here from the original matlab code because</span>
    <span class="c1"># there was an error on return when arnorm==0</span>
    <span class="n">arnorm</span> <span class="o">=</span> <span class="n">alfa</span> <span class="o">*</span> <span class="n">beta</span>
    <span class="k">if</span> <span class="n">arnorm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">istop</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">r1norm</span><span class="p">,</span> <span class="n">r2norm</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">acond</span><span class="p">,</span> <span class="n">arnorm</span><span class="p">,</span> <span class="n">xnorm</span>

    <span class="n">head1</span> <span class="o">=</span> <span class="s1">&#39;   Itn      x[0]       r1norm     r2norm &#39;</span>
    <span class="n">head2</span> <span class="o">=</span> <span class="s1">&#39; Compatible    LS      Norm A   Cond A&#39;</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">head1</span><span class="p">,</span> <span class="n">head2</span><span class="p">)</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">test2</span> <span class="o">=</span> <span class="n">alfa</span> <span class="o">/</span> <span class="n">beta</span>
        <span class="n">str1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{itn:6g}</span><span class="s1"> {x.dofs([0])[0]:12.5e}&#39;</span>
        <span class="n">str2</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{r1norm:10.3e}</span><span class="s1"> </span><span class="si">{r2norm:10.3e}</span><span class="s1">&#39;</span>
        <span class="n">str3</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  </span><span class="si">{test1:8.1e}</span><span class="s1"> </span><span class="si">{test2:8.1e}</span><span class="s1">&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="n">str3</span><span class="p">)</span>

    <span class="c1"># Main iteration loop.</span>
    <span class="k">while</span> <span class="n">itn</span> <span class="o">&lt;</span> <span class="n">iter_lim</span><span class="p">:</span>
        <span class="n">itn</span> <span class="o">=</span> <span class="n">itn</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        %     Perform the next step of the bidiagonalization to obtain the</span>
<span class="sd">        %     next  beta, u, alfa, v.  These satisfy the relations</span>
<span class="sd">        %                beta*u  =  a*v   -  alfa*u,</span>
<span class="sd">        %                alfa*v  =  A&#39;*u  -  beta*v.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span> <span class="o">*</span> <span class="n">alfa</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">anorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">anorm</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">alfa</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">beta</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">damp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply_adjoint</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">v</span> <span class="o">*</span> <span class="n">beta</span>
            <span class="n">alfa</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">alfa</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alfa</span><span class="p">)</span>

        <span class="c1"># Use a plane rotation to eliminate the damping parameter.</span>
        <span class="c1"># This alters the diagonal (rhobar) of the lower-bidiagonal matrix.</span>
        <span class="n">rhobar1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rhobar</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">damp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cs1</span> <span class="o">=</span> <span class="n">rhobar</span> <span class="o">/</span> <span class="n">rhobar1</span>
        <span class="n">sn1</span> <span class="o">=</span> <span class="n">damp</span> <span class="o">/</span> <span class="n">rhobar1</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">sn1</span> <span class="o">*</span> <span class="n">phibar</span>
        <span class="n">phibar</span> <span class="o">=</span> <span class="n">cs1</span> <span class="o">*</span> <span class="n">phibar</span>

        <span class="c1"># Use a plane rotation to eliminate the subdiagonal element (beta)</span>
        <span class="c1"># of the lower-bidiagonal matrix, giving an upper-bidiagonal matrix.</span>
        <span class="n">cs</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">_sym_ortho</span><span class="p">(</span><span class="n">rhobar1</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">alfa</span>
        <span class="n">rhobar</span> <span class="o">=</span> <span class="o">-</span><span class="n">cs</span> <span class="o">*</span> <span class="n">alfa</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">cs</span> <span class="o">*</span> <span class="n">phibar</span>
        <span class="n">phibar</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">phibar</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">phi</span>

        <span class="c1"># Update x and w.</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">/</span> <span class="n">rho</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="o">-</span><span class="n">theta</span> <span class="o">/</span> <span class="n">rho</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">rho</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t1</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t2</span>
        <span class="n">ddnorm</span> <span class="o">=</span> <span class="n">ddnorm</span> <span class="o">+</span> <span class="n">dk</span><span class="o">.</span><span class="n">l2_norm2</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Use a plane rotation on the right to eliminate the</span>
        <span class="c1"># super-diagonal element (theta) of the upper-bidiagonal matrix.</span>
        <span class="c1"># Then use the result to estimate norm(x).</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">sn2</span> <span class="o">*</span> <span class="n">rho</span>
        <span class="n">gambar</span> <span class="o">=</span> <span class="o">-</span><span class="n">cs2</span> <span class="o">*</span> <span class="n">rho</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">zbar</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">/</span> <span class="n">gambar</span>
        <span class="n">xnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xxnorm</span> <span class="o">+</span> <span class="n">zbar</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gambar</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">theta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cs2</span> <span class="o">=</span> <span class="n">gambar</span> <span class="o">/</span> <span class="n">gamma</span>
        <span class="n">sn2</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">gamma</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">/</span> <span class="n">gamma</span>
        <span class="n">xxnorm</span> <span class="o">=</span> <span class="n">xxnorm</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Test for convergence.</span>
        <span class="c1"># First, estimate the condition of the matrix  Abar,</span>
        <span class="c1"># and the norms of  rbar  and  Abar&#39;rbar.</span>
        <span class="n">acond</span> <span class="o">=</span> <span class="n">anorm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ddnorm</span><span class="p">)</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="n">phibar</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="n">res2</span> <span class="o">+</span> <span class="n">psi</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">rnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">res1</span> <span class="o">+</span> <span class="n">res2</span><span class="p">)</span>
        <span class="n">arnorm</span> <span class="o">=</span> <span class="n">alfa</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

        <span class="c1"># Distinguish between</span>
        <span class="c1">#    r1norm = ||b - Ax|| and</span>
        <span class="c1">#    r2norm = rnorm in current code</span>
        <span class="c1">#           = sqrt(r1norm^2 + damp^2*||x||^2).</span>
        <span class="c1">#    Estimate r1norm from</span>
        <span class="c1">#    r1norm = sqrt(r2norm^2 - damp^2*||x||^2).</span>
        <span class="c1"># Although there is cancellation, it might be accurate enough.</span>
        <span class="n">r1sq</span> <span class="o">=</span> <span class="n">rnorm</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dampsq</span> <span class="o">*</span> <span class="n">xxnorm</span>
        <span class="n">r1norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r1sq</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">r1sq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r1norm</span> <span class="o">=</span> <span class="o">-</span><span class="n">r1norm</span>
        <span class="n">r2norm</span> <span class="o">=</span> <span class="n">rnorm</span>

        <span class="c1"># Now use these norms to estimate certain other quantities,</span>
        <span class="c1"># some of which will be small near a solution.</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="n">rnorm</span> <span class="o">/</span> <span class="n">bnorm</span>
        <span class="n">test2</span> <span class="o">=</span> <span class="n">arnorm</span> <span class="o">/</span> <span class="p">(</span><span class="n">anorm</span> <span class="o">*</span> <span class="n">rnorm</span><span class="p">)</span>
        <span class="n">test3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">acond</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">test1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">anorm</span> <span class="o">*</span> <span class="n">xnorm</span> <span class="o">/</span> <span class="n">bnorm</span><span class="p">)</span>
        <span class="n">rtol</span> <span class="o">=</span> <span class="n">btol</span> <span class="o">+</span> <span class="n">atol</span> <span class="o">*</span> <span class="n">anorm</span> <span class="o">*</span> <span class="n">xnorm</span> <span class="o">/</span> <span class="n">bnorm</span>

        <span class="c1"># The following tests guard against extremely small values of</span>
        <span class="c1"># atol, btol  or  ctol.  (The user may have set any or all of</span>
        <span class="c1"># the parameters  atol, btol, conlim  to 0.)</span>
        <span class="c1"># The effect is equivalent to the normal tests using</span>
        <span class="c1"># atol = eps,  btol = eps,  conlim = 1/eps.</span>
        <span class="k">if</span> <span class="n">itn</span> <span class="o">&gt;=</span> <span class="n">iter_lim</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">7</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">test3</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">test2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c1"># Allow for tolerances set by the user.</span>
        <span class="k">if</span> <span class="n">test3</span> <span class="o">&lt;=</span> <span class="n">ctol</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">test2</span> <span class="o">&lt;=</span> <span class="n">atol</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">test1</span> <span class="o">&lt;=</span> <span class="n">rtol</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># See if it is time to print something.</span>
        <span class="n">prnt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">40</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">itn</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">itn</span> <span class="o">&gt;=</span> <span class="n">iter_lim</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># if itn%10 == 0: prnt = True</span>
        <span class="k">if</span> <span class="n">test3</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">ctol</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">test2</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">*</span><span class="n">atol</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">test1</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">*</span><span class="n">rtol</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">istop</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prnt</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">prnt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
                <span class="n">str1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{itn:6g}</span><span class="s1"> {x.dofs([0])[0]:12.5e}&#39;</span>
                <span class="n">str2</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{r1norm:10.3e}</span><span class="s1"> </span><span class="si">{r2norm:10.3e}</span><span class="s1">&#39;</span>
                <span class="n">str3</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  </span><span class="si">{test1:8.1e}</span><span class="s1"> </span><span class="si">{test2:8.1e}</span><span class="s1">&#39;</span>
                <span class="n">str4</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{anorm:8.1e}</span><span class="s1"> </span><span class="si">{acond:8.1e}</span><span class="s1">&#39;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="n">str3</span><span class="p">,</span> <span class="n">str4</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">istop</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># End of iteration loop.</span>
    <span class="c1"># Print the stopping condition.</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LSQR finished&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">istop</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">str1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;istop =</span><span class="si">{istop:8g}</span><span class="s1">   r1norm =</span><span class="si">{r1norm:8.1e}</span><span class="s1">&#39;</span>
        <span class="n">str2</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;anorm =</span><span class="si">{anorm:8.1e}</span><span class="s1">   arnorm =</span><span class="si">{arnorm:8.1e}</span><span class="s1">&#39;</span>
        <span class="n">str3</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;itn   =</span><span class="si">{itn:8g}</span><span class="s1">   r2norm =</span><span class="si">{r2norm:8.1e}</span><span class="s1">&#39;</span>
        <span class="n">str4</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;acond =</span><span class="si">{acond:8.1e}</span><span class="s1">   xnorm  =</span><span class="si">{xnorm:8.1e}</span><span class="s1">&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str1</span> <span class="o">+</span> <span class="s1">&#39;   &#39;</span> <span class="o">+</span> <span class="n">str2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str3</span> <span class="o">+</span> <span class="s1">&#39;   &#39;</span> <span class="o">+</span> <span class="n">str4</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">istop</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">r1norm</span><span class="p">,</span> <span class="n">r2norm</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">acond</span><span class="p">,</span> <span class="n">arnorm</span><span class="p">,</span> <span class="n">xnorm</span></div>


<span class="c1"># The following code is an adapted version of</span>
<span class="c1"># scipy.sparse.linalg.lsqr.</span>
<span class="c1"># Original copyright notice:</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2010 David Fong and Michael Saunders</span>
<span class="c1">#</span>
<span class="c1"># LSMR uses an iterative method.</span>
<span class="c1">#</span>
<span class="c1"># 07 Jun 2010: Documentation updated</span>
<span class="c1"># 03 Jun 2010: First release version in Python</span>
<span class="c1">#</span>
<span class="c1"># David Chin-lung Fong            clfong@stanford.edu</span>
<span class="c1"># Institute for Computational and Mathematical Engineering</span>
<span class="c1"># Stanford University</span>
<span class="c1">#</span>
<span class="c1"># Michael Saunders                saunders@stanford.edu</span>
<span class="c1"># Systems Optimization Laboratory</span>
<span class="c1"># Dept of MS&amp;E, Stanford University.</span>


<div class="viewcode-block" id="lsmr"><a class="viewcode-back" href="../../../generated/pymor.algorithms.html#pymor.algorithms.genericsolvers.lsmr">[docs]</a><span class="k">def</span> <span class="nf">lsmr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">damp</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">btol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">conlim</span><span class="o">=</span><span class="mf">1e8</span><span class="p">,</span>
         <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The exact solution is  x = 0                              &#39;</span><span class="p">,</span>
           <span class="s1">&#39;Ax - b is small enough, given atol, btol                  &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The least-squares solution is good enough, given atol     &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The estimate of cond(Abar) has exceeded conlim            &#39;</span><span class="p">,</span>
           <span class="s1">&#39;Ax - b is small enough for this machine                   &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The least-squares solution is good enough for this machine&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Cond(Abar) seems to be too large for this machine         &#39;</span><span class="p">,</span>
           <span class="s1">&#39;The iteration limit has been reached                      &#39;</span><span class="p">)</span>

    <span class="n">hdg1</span> <span class="o">=</span> <span class="s1">&#39;   itn      x(1)       norm r    norm A&#39;&#39;r&#39;</span>
    <span class="n">hdg2</span> <span class="o">=</span> <span class="s1">&#39; compatible   LS      norm A   cond A&#39;</span>
    <span class="n">pfreq</span> <span class="o">=</span> <span class="mi">20</span>   <span class="c1"># print frequency (for repeating the heading)</span>
    <span class="n">pcount</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># print counter</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">dim</span>

    <span class="c1"># stores the num of singular values</span>
    <span class="n">minDim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">maxiter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">maxiter</span> <span class="o">=</span> <span class="n">minDim</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LSMR            Least-squares solution of  Ax = b</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;The matrix A has </span><span class="si">{m:8g}</span><span class="s1"> rows  and </span><span class="si">{n:8g}</span><span class="s1"> cols&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;damp = </span><span class="si">%20.14e</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">damp</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;atol = </span><span class="si">{atol:8.2e}</span><span class="s1">                 conlim = </span><span class="si">{conlim:8.2e}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;btol = </span><span class="si">{btol:8.2e}</span><span class="s1">             maxiter = </span><span class="si">{maxiter:8g}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">u</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply_adjoint</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">v</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="c1"># Initialize variables for 1st iteration.</span>

    <span class="n">itn</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">zetabar</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span>
    <span class="n">alphabar</span> <span class="o">=</span> <span class="n">alpha</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rhobar</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sbar</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">hbar</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>

    <span class="c1"># Initialize variables for estimation of ||r||.</span>

    <span class="n">betadd</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="n">betad</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rhodold</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">tautildeold</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">thetatilde</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">zeta</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Initialize variables for estimation of ||A|| and cond(A)</span>

    <span class="n">normA2</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">alpha</span>
    <span class="n">maxrbar</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">minrbar</span> <span class="o">=</span> <span class="mf">1e+100</span>
    <span class="n">normA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normA2</span><span class="p">)</span>
    <span class="n">condA</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">normx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Items for use in stopping rules.</span>
    <span class="n">normb</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="n">istop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ctol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">conlim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ctol</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">conlim</span>
    <span class="n">normr</span> <span class="o">=</span> <span class="n">beta</span>

    <span class="c1"># Reverse the order here from the original matlab code because</span>
    <span class="c1"># there was an error on return when arnorm==0</span>
    <span class="n">normar</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span>
    <span class="k">if</span> <span class="n">normar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">istop</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">normr</span><span class="p">,</span> <span class="n">normar</span><span class="p">,</span> <span class="n">normA</span><span class="p">,</span> <span class="n">condA</span><span class="p">,</span> <span class="n">normx</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">hdg1</span><span class="p">,</span> <span class="n">hdg2</span><span class="p">)</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">test2</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">beta</span>
        <span class="n">str1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{itn:6g}</span><span class="s1"> {x.dofs([0])[0]:12.5e}&#39;</span>
        <span class="n">str2</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{normr:10.3e}</span><span class="s1"> </span><span class="si">{normar:10.3e}</span><span class="s1">&#39;</span>
        <span class="n">str3</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  </span><span class="si">{test1:8.1e}</span><span class="s1"> </span><span class="si">{test2:8.1e}</span><span class="s1">&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="n">str3</span><span class="p">]))</span>

    <span class="c1"># Main iteration loop.</span>
    <span class="k">while</span> <span class="n">itn</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
        <span class="n">itn</span> <span class="o">=</span> <span class="n">itn</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Perform the next step of the bidiagonalization to obtain the</span>
        <span class="c1"># next  beta, u, alpha, v.  These satisfy the relations</span>
        <span class="c1">#         beta*u  =  a*v   -  alpha*u,</span>
        <span class="c1">#        alpha*v  =  A&#39;*u  -  beta*v.</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span> <span class="o">*</span> <span class="n">alpha</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">apply_adjoint</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">v</span> <span class="o">*</span> <span class="n">beta</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">scal</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># At this point, beta = beta_{k+1}, alpha = alpha_{k+1}.</span>

        <span class="c1"># Construct rotation Qhat_{k,2k+1}.</span>

        <span class="n">chat</span><span class="p">,</span> <span class="n">shat</span><span class="p">,</span> <span class="n">alphahat</span> <span class="o">=</span> <span class="n">_sym_ortho</span><span class="p">(</span><span class="n">alphabar</span><span class="p">,</span> <span class="n">damp</span><span class="p">)</span>

        <span class="c1"># Use a plane rotation (Q_i) to turn B_i to R_i</span>

        <span class="n">rhoold</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">_sym_ortho</span><span class="p">(</span><span class="n">alphahat</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">thetanew</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="n">alpha</span>
        <span class="n">alphabar</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">alpha</span>

        <span class="c1"># Use a plane rotation (Qbar_i) to turn R_i^T to R_i^bar</span>

        <span class="n">rhobarold</span> <span class="o">=</span> <span class="n">rhobar</span>
        <span class="n">zetaold</span> <span class="o">=</span> <span class="n">zeta</span>
        <span class="n">thetabar</span> <span class="o">=</span> <span class="n">sbar</span> <span class="o">*</span> <span class="n">rho</span>
        <span class="n">rhotemp</span> <span class="o">=</span> <span class="n">cbar</span> <span class="o">*</span> <span class="n">rho</span>
        <span class="n">cbar</span><span class="p">,</span> <span class="n">sbar</span><span class="p">,</span> <span class="n">rhobar</span> <span class="o">=</span> <span class="n">_sym_ortho</span><span class="p">(</span><span class="n">cbar</span> <span class="o">*</span> <span class="n">rho</span><span class="p">,</span> <span class="n">thetanew</span><span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">cbar</span> <span class="o">*</span> <span class="n">zetabar</span>
        <span class="n">zetabar</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sbar</span> <span class="o">*</span> <span class="n">zetabar</span>

        <span class="c1"># Update h, h_hat, x.</span>

        <span class="n">hbar</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="n">hbar</span> <span class="o">*</span> <span class="p">(</span><span class="n">thetabar</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">/</span> <span class="p">(</span><span class="n">rhoold</span> <span class="o">*</span> <span class="n">rhobarold</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">hbar</span> <span class="o">*</span> <span class="p">(</span><span class="n">zeta</span> <span class="o">/</span> <span class="p">(</span><span class="n">rho</span> <span class="o">*</span> <span class="n">rhobar</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">thetanew</span> <span class="o">/</span> <span class="n">rho</span><span class="p">)</span>

        <span class="c1"># Estimate of ||r||.</span>

        <span class="c1"># Apply rotation Qhat_{k,2k+1}.</span>
        <span class="n">betaacute</span> <span class="o">=</span> <span class="n">chat</span> <span class="o">*</span> <span class="n">betadd</span>
        <span class="n">betacheck</span> <span class="o">=</span> <span class="o">-</span><span class="n">shat</span> <span class="o">*</span> <span class="n">betadd</span>

        <span class="c1"># Apply rotation Q_{k,k+1}.</span>
        <span class="n">betahat</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">betaacute</span>
        <span class="n">betadd</span> <span class="o">=</span> <span class="o">-</span><span class="n">s</span> <span class="o">*</span> <span class="n">betaacute</span>

        <span class="c1"># Apply rotation Qtilde_{k-1}.</span>
        <span class="c1"># betad = betad_{k-1} here.</span>

        <span class="n">thetatildeold</span> <span class="o">=</span> <span class="n">thetatilde</span>
        <span class="n">ctildeold</span><span class="p">,</span> <span class="n">stildeold</span><span class="p">,</span> <span class="n">rhotildeold</span> <span class="o">=</span> <span class="n">_sym_ortho</span><span class="p">(</span><span class="n">rhodold</span><span class="p">,</span> <span class="n">thetabar</span><span class="p">)</span>
        <span class="n">thetatilde</span> <span class="o">=</span> <span class="n">stildeold</span> <span class="o">*</span> <span class="n">rhobar</span>
        <span class="n">rhodold</span> <span class="o">=</span> <span class="n">ctildeold</span> <span class="o">*</span> <span class="n">rhobar</span>
        <span class="n">betad</span> <span class="o">=</span> <span class="o">-</span> <span class="n">stildeold</span> <span class="o">*</span> <span class="n">betad</span> <span class="o">+</span> <span class="n">ctildeold</span> <span class="o">*</span> <span class="n">betahat</span>

        <span class="c1"># betad   = betad_k here.</span>
        <span class="c1"># rhodold = rhod_k  here.</span>

        <span class="n">tautildeold</span> <span class="o">=</span> <span class="p">(</span><span class="n">zetaold</span> <span class="o">-</span> <span class="n">thetatildeold</span> <span class="o">*</span> <span class="n">tautildeold</span><span class="p">)</span> <span class="o">/</span> <span class="n">rhotildeold</span>
        <span class="n">taud</span> <span class="o">=</span> <span class="p">(</span><span class="n">zeta</span> <span class="o">-</span> <span class="n">thetatilde</span> <span class="o">*</span> <span class="n">tautildeold</span><span class="p">)</span> <span class="o">/</span> <span class="n">rhodold</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">betacheck</span> <span class="o">*</span> <span class="n">betacheck</span>
        <span class="n">normr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="p">(</span><span class="n">betad</span> <span class="o">-</span> <span class="n">taud</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">betadd</span> <span class="o">*</span> <span class="n">betadd</span><span class="p">)</span>

        <span class="c1"># Estimate ||A||.</span>
        <span class="n">normA2</span> <span class="o">=</span> <span class="n">normA2</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">normA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normA2</span><span class="p">)</span>
        <span class="n">normA2</span> <span class="o">=</span> <span class="n">normA2</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">alpha</span>

        <span class="c1"># Estimate cond(A).</span>
        <span class="n">maxrbar</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxrbar</span><span class="p">,</span> <span class="n">rhobarold</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itn</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">minrbar</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minrbar</span><span class="p">,</span> <span class="n">rhobarold</span><span class="p">)</span>
        <span class="n">condA</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxrbar</span><span class="p">,</span> <span class="n">rhotemp</span><span class="p">)</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">minrbar</span><span class="p">,</span> <span class="n">rhotemp</span><span class="p">)</span>

        <span class="c1"># Test for convergence.</span>

        <span class="c1"># Compute norms for convergence testing.</span>
        <span class="n">normar</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zetabar</span><span class="p">)</span>
        <span class="n">normx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Now use these norms to estimate certain other quantities,</span>
        <span class="c1"># some of which will be small near a solution.</span>

        <span class="n">test1</span> <span class="o">=</span> <span class="n">normr</span> <span class="o">/</span> <span class="n">normb</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normA</span> <span class="o">*</span> <span class="n">normr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">test2</span> <span class="o">=</span> <span class="n">normar</span> <span class="o">/</span> <span class="p">(</span><span class="n">normA</span> <span class="o">*</span> <span class="n">normr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span>
        <span class="n">test3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">condA</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">test1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">normA</span> <span class="o">*</span> <span class="n">normx</span> <span class="o">/</span> <span class="n">normb</span><span class="p">)</span>
        <span class="n">rtol</span> <span class="o">=</span> <span class="n">btol</span> <span class="o">+</span> <span class="n">atol</span> <span class="o">*</span> <span class="n">normA</span> <span class="o">*</span> <span class="n">normx</span> <span class="o">/</span> <span class="n">normb</span>

        <span class="c1"># The following tests guard against extremely small values of</span>
        <span class="c1"># atol, btol or ctol.  (The user may have set any or all of</span>
        <span class="c1"># the parameters atol, btol, conlim  to 0.)</span>
        <span class="c1"># The effect is equivalent to the normAl tests using</span>
        <span class="c1"># atol = eps,  btol = eps,  conlim = 1/eps.</span>

        <span class="k">if</span> <span class="n">itn</span> <span class="o">&gt;=</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">7</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">test3</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">test2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">t1</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c1"># Allow for tolerances set by the user.</span>

        <span class="k">if</span> <span class="n">test3</span> <span class="o">&lt;=</span> <span class="n">ctol</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">test2</span> <span class="o">&lt;=</span> <span class="n">atol</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">test1</span> <span class="o">&lt;=</span> <span class="n">rtol</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># See if it is time to print something.</span>

        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">40</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">itn</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">itn</span> <span class="o">&gt;=</span> <span class="n">maxiter</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">itn</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">test3</span> <span class="o">&lt;=</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">ctol</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">test2</span> <span class="o">&lt;=</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">atol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">test1</span> <span class="o">&lt;=</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">rtol</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">istop</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">pcount</span> <span class="o">&gt;=</span> <span class="n">pfreq</span><span class="p">:</span>
                    <span class="n">pcount</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">hdg1</span><span class="p">,</span> <span class="n">hdg2</span><span class="p">)</span>
                <span class="n">pcount</span> <span class="o">=</span> <span class="n">pcount</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">str1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{itn:6g}</span><span class="s1"> {x.dofs([0])[0]:12.5e}&#39;</span>
                <span class="n">str2</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{normr:10.3e}</span><span class="s1"> </span><span class="si">{normar:10.3e}</span><span class="s1">&#39;</span>
                <span class="n">str3</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  </span><span class="si">{test1:8.1e}</span><span class="s1"> </span><span class="si">{test2:8.1e}</span><span class="s1">&#39;</span>
                <span class="n">str4</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{normA:8.1e}</span><span class="s1"> </span><span class="si">{condA:8.1e}</span><span class="s1">&#39;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="n">str3</span><span class="p">,</span> <span class="n">str4</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">istop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Print the stopping condition.</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LSMR finished&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">istop</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;istop =</span><span class="si">{istop:8g}</span><span class="s1">    normr =</span><span class="si">{normr:8.1e}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;    normA =</span><span class="si">{normA:8.1e}</span><span class="s1">    normAr =</span><span class="si">{normar:8.1e}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;itn   =</span><span class="si">{itn:8g}</span><span class="s1">    condA =</span><span class="si">{condA:8.1e}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    normx =</span><span class="si">%8.1e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">normx</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">str3</span><span class="p">,</span> <span class="n">str4</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">istop</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">normr</span><span class="p">,</span> <span class="n">normar</span><span class="p">,</span> <span class="n">normA</span><span class="p">,</span> <span class="n">condA</span><span class="p">,</span> <span class="n">normx</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pyMOR v2019.2rc0+680.g9bf3f73a.dirty Manual</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2019 pyMOR developers and contributors.
      Last updated on Dec 05, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>