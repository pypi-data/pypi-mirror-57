import os
import sys
import re
import yaml
import collections
import argparse
from jinja2 import PackageLoader, Environment, FileSystemLoader, BaseLoader
from jinja2.exceptions import TemplateSyntaxError, TemplateError

from string import Template
from epm.worker.api import WorkerAPI
from conans.client.profile_loader import read_profile
__dir__ = os.path.abspath(os.path.dirname(__file__))
__me__ = os.path.relpath(__file__, os.path.dirname('.')).replace('\\', '/')
###################################################
# me : __file__ relative path to .gitlab-ci.yml
#
# Layouts
#
# Prolog
# Stages
# [ Windos | linux | Linux_cross ]+
# (Pages)?
# (Docs)?

Prolog = '''#
#  This GitLab CI config file was generated by {{me}} with command.
#    {{ commandline }}
#  Please don't modify this directly, if you want to change config,  
#  you'd better to edit {{me}} and regenerate instead. 
#
'''
Stages = '''
stages:
- build
- test
- deploy
'''
Windows = '''
build:{{ configuration }}:
  stage: build
  tags:  
  - Windows
  - EPM
  - {{ builder }}
  artifacts:
    paths:
    - .epm
    - .conan    
  script:
  - epm -c {{ configuration }} create --cache --clear --runner shell
      
test:{{ configuration }}:
  stage: test
  tags:
  - Windows
  - runner

  dependencies:
  - build:{{ configuration }}
    
  script:
{%- for (name, args) in tests %}
  - .epm/{{ configuration }}/sandbox/{{ name }} {{ args }}
{%- endfor %}

deploy:{{ configuration }}:
  stage: deploy
  tags:
  - Windows
  - EPM
  - deployer
  dependencies:
  - build:{{ configuration }}
  script:
  - epm -c {{ configuration }} upload
'''
Linux = '''
build:{{ configuration }}:
  stage: build
  image: {{ builder }}
  tags:  
    - Linux
    - docker-executor
    - builder
  artifacts:
    paths:
    - .epm
    - .conan
  script:
  - epm -c {{ configuration }}  create --cache --clear  --runner shell
  
test:{{ configuration }}:
  stage: test  
  image: {{ runner }}
  tags:
  - Linux
  - docker-executor
  - runner
  dependencies:
  - build:{{ configuration }}
  script:
{%- for (name, args) in tests %}
  - ./.epm/{{ configuration }}/sandbox/{{ name }} {{ args }}
{%- endfor %}
 
deploy:{{ configuration }}:
  stage: deploy  
  image: {{ deployer }}
  tags:
  - Linux
  - docker-executor
  - deployer
  dependencies:
  - build:{{ configuration }}  
  script:
  - epm -c {{ configuration }} upload
'''
Linux_cross = '''
build:{{ configuration }}:
  stage: build
  image: {{ builder }}
  tags:  
  - Linux
  - docker-executor
  - builder
  artifacts:
    paths:
    - .epm
    - .conan
  script:
  - epm -c {{ configuration }}  create --cache --clear  --runner shell

test:{{ configuration }}:
  stage: test
  tags:
  - Linux
  - docker-executor
  - device-agent
  dependencies:
    - build:{{ configuration }}
  script:
{%- for (name, args) in tests %}
  - epm -c {{ configuration }} sandbox {{ name }} {{ args }}
{%- endfor %}

deploy:{{ configuration }}:
  stage: deploy  
  image: {{ deployer }}
  tags:
  - Linux
  - docker-executor
  - deployer
  dependencies:
  - build:{{ configuration }}  
  script:
  - epm -c {{ configuration }} upload
'''
Docs = '''
##############################################################
#           EPM Docs
##############################################################
build:docs:
  stage: build
  image: epmall/gcc5
  tags:  
  - Linux
  - docker-executor
  - docman
  artifacts:
    paths:
    - .epm/site
  script:
  - epm mkdocs --build --site-dir .epm/site/@{name}/@{version}
  only:
    variables:
    - $CI_COMMIT_REF_PROTECTED == "true"  

publish:docs:
  stage: deploy
  image: epmall/gcc5
  tags:  
  - Linux
  - docker-executor
  - docman
  dependencies:
  - build:docs
  script:
  - epm mkdocs --upload --site-dir .epm/site/@{name}
  only:
    variables:
    - $CI_COMMIT_REF_PROTECTED == "true"  
'''
Pages = '''
##############################################################
#           Gitlab Page
##############################################################
pages:
  stage: deploy
  image: epmall/gcc5
  tags:  
  - Linux
  - docker-executor
  - gitlab-pages
  script:
  - epm mkdocs --build --site-dir .epm/site
  - mv .epm/site public
  artifacts:
    paths:
    - public
  only:
    variables:
    - $CI_COMMIT_REF_PROTECTED == "true"
'''

TESTs=[
@TESTs@
]

ProfileSuffix = ['', '.d']
####    You may do above script template as your needs.   ####



class Generator(object):

    def __init__(self, args):
        self._args = args
        api = WorkerAPI()
        api.create_app()
        self._profiles = api.worker.profiles
        self._manifest = None
        self._schemes = None
        self._tests = TESTs

    @property
    def profiles(self):
        return self._profiles

    @property
    def schemes(self):
        if self._schemes is None:
            schemes = list(self.manifest.get('configuration', {}).get('scheme', {}).keys())
            if 'default' not in schemes:
                schemes = ['default'] + schemes
            self._schemes = schemes
        return self._schemes

    @property
    def manifest(self):
        if self._manifest is None:
            with open('package.yml') as f:
                self._manifest = yaml.safe_load(f)
        return self._manifest

    @property
    def tests(self):
        return self._tests

    def _job(self, name, suffix=''):
        profile = self.profiles.get(name, None)
        if profile is None:
            raise Exception('package.yml configuration.profile {} not installed.'.format(name))

        docker = profile[name].get('docker', {})
        builder = docker.get('builder', {}).get('image')
        runner = docker.get('runner', {}).get('image')

        d = os.path.dirname(profile['__file__'])
        pr, _ = read_profile(name, d, d)

        template = None
        deployer = 'epmall/gcc5'
        if pr.settings['compiler'] == 'Visual Studio':
            template = Windows
            builder = 'VS2019'
        elif pr.settings['compiler'] == 'gcc' and pr.settings['arch'] in ['x86', 'x86_64']:
            template = Linux
        elif pr.settings['compiler'] == 'gcc' and pr.settings['arch'] in ['armv7']:
            template = Linux_cross
        else:
            print(pr.settings['compiler'], pr.settings['arch'])
            raise Exception('Not find tempalte')
        fullname = name + suffix
        content = '\n\n###########################################################'
        content += '\n#                ' + fullname
        content += '\n###########################################################'
        for scheme in self.schemes:
            configuration = fullname if scheme == 'default' else ("%s@%s" % (fullname, scheme,))
            content +='\n#     -- %s  --' % scheme
            content += self._render(template,
                                    configuration=configuration,
                                    scheme=scheme,
                                    runner=runner,
                                    builder=builder,
                                    deployer=deployer)
        return content

    def _render(self, template, *args, **kwargs):
        """ Render the template using keyword arguments as local variables. """
        env = {'args': self._args, 'package': self.manifest, 'tests': self.tests,
               'me': __me__,                'commandline': " ".join(sys.argv)}

        for dictarg in args:
            env.update(dictarg)
        env.update(kwargs)
        try:
            jtemplate = Environment(loader=BaseLoader()).from_string(template)
            return jtemplate.render(env)
        except Exception as e:
            e.translated = False
            print("\n%s\n" % str(e))
            i = 1
            for line in template.split('\n'):
                print('%d:' % i, line)
                i += 1
            raise e

    def render(self, filename='.gitlab-ci.yml'):
        content = self._render(Prolog)
        content += self._render(Stages)

        for name in self.manifest.get('configuration', {}).get('profile', []):
            profile = self.profiles.get(name, None)
            if profile is None:
                raise Exception('package.yml configuration.profile {} not installed.'.format(name))
            for suffix in ProfileSuffix:
                content += self._job(name, suffix)


        if self._args.pages:
            content += self._render(Pages)
        if not self._args.no_docs:
            content += self._render(Docs)

        if filename:
            with open(filename, 'w') as f:
                f.write(content)

        return content



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.description = 'Generage Gitlab CI config file according package.yml'
    parser.add_argument("--pages", default=False, action="store_true",
                        help="Add Gitlab pages deploy job")
    parser.add_argument("--no-docs", default=False, action="store_true",
                        help="Add EPM docs deploy job")
    args = parser.parse_args()
    generator = Generator(args)
    filename = '.gitlab-ci.yml'
    generator.render(filename)

    print('generated %s done!' %filename)
